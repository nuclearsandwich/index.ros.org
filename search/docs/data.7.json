[{"id":28,"url":"/doc/ros2/Contributing/Quality-Guide/","title":"Quality Guide: Ensuring code quality","content":"\nQuality Guide: Ensuring code quality¶\nThis section tries to give guidance about how to improve the software quality of ROS2 packages. The guide uses a pattern language based approach to improve the readers experience (“read little, understand fast, understand much, apply easily”).\nWhat this sections is about:\n\nROS2 core, application and ecosystem packages.\nROS2 core client libraries C++ and Python (right now: mainly C++)\nDesign and implementation considerations to improve quality attributes like “Reliability”, “Security”, “Maintainability”, “Determinism”, etc. which relate to non-functional requirements (right now: mainly “Reliability”).\n\nWhat this section is not about:\n\nDesign and implementation considerations which go beyond a single ROS2 package and a single ROS2 node (means no integration considerations w.r.t. ROS2 graphs, etc.).\nOrganizational considerations to improve software quality (an organizations structure and processes, etc.).\nInfrastructural considerations which go beyond a single repository (overall continuous integration infrastructure, etc.)\n\nRelation to other sections:\n\nThe Design Guide summarizes design patterns for ROS2 packages. As quality is highly impacted by design it is a good idea to have a look into it before.\nThe Developer Guide explains what to consider when contributing to ROS2 packages w.r.t. to contribution workflow (organizational), coding conventions, documentation considerations, etc. All these consideration may have an impact on single or several quality attributes.\n\n\nPatterns¶\n\nStatic code analysis\nStatic code analysis using a single tool\nStatic code analysis using multiple tools complementary\nStatic code analysis as part of the ament package build\n\n\nDynamic code analysis\nROS2 library test\n(referencing of generic unit test patterns like from xUnitPatterns with references to C++ gtest+gmock/Python unittest implementations)\n(ROS2 specific unit test use cases)\nProperty based test (C++ RapidCheck / Python hypothesis)\nCode coverage analysis\n\n\nROS2 node unit test\n(generic use cases of launch based tests)\n\n\n\n\n\nStatic code analysis as part of the ament package build¶\nContext:\n\nYou have developed your C++ production code.\nYou have created a ROS2 package with build support with ament.\n\nProblem:\n\nLibrary level static code analysis is not run as part of the package build procedure.\nLibrary level static code analysis needs to be executed manually.\nRisk of forgetting to execute library level static code analysis before building\na new package version.\n\nSolution:\n\nUse the integration capabilities of ament to execute static code analysis as\npart of the package build procedure.\n\nImplementation:\n\nInsert into the packages CMakeLists.txt file.\n\n...\nif(BUILD_TESTING)\n  find_package(ament_lint_auto REQUIRED)\n  ament_lint_auto_find_test_dependencies()\n  ...\nendif()\n...\n\n\n\nInsert the ament_lint test dependencies into the packages package.xml file.\n\n...\n<package format=\"2\">\n  ...\n  <test_depend>ament_lint_auto</test_depend>\n  <test_depend>ament_lint_common</test_depend>\n  ...\n</package>\n\n\nExamples:\n\nrclcpp:\nrclcpp/rclcpp/CMakeLists.txt\nrclcpp/rclcpp/package.xml\n\n\nrclcpp_lifecycle:\nrclcpp/rclcpp_lifecycle/CMakeLists.txt\nrclcpp/rclcpp_lifecycle/package.xml\n\n\n\nResulting context:\n\nThe static code analysis tools supported by ament are run as part of the package build.\nStatic code analysis tools not supported by ament need to be executed separately.\n\n\n\nDynamic analysis (data races & deadlocks)¶\nContext:\n\nYou are developing/debugging your multithreaded C++ production code.\nYou use pthreads or C++11 threading + llvm libc++ (in case of ThreadSanatizer).\nYou do not use Libc/libstdc++ static linking (in case of ThreadSanatizer).\nYou do not build non-position-independent executables (in case of ThreadSanatizer).\n\nProblem:\n\nData races and deadlocks can lead to critical bugs.\nData races and deadlocks cannot be detected using static analysis (reason: limitation of static analysis).\nData races and deadlocks must not show up during development debugging / testing (reason: usually not all possible control paths through production code exercised).\n\nSolution:\n\nUse a dynamic analysis tool which focuses on finding data races and deadlocks (here clang ThreadSanatizer).\n\nImplementation:\n\nCompile and link the production code with clang using the option -fsanitize=thread (this instruments the production code).\nIn case different production code shall be executed during anaylsis consider conditional compilation e.g. ThreadSanatizers _has_feature(thread_sanitizer).\nIn case some code shall not be instrumented consider ThreadSanatizers _/*attribute*/_((no_sanitize(“thread”))).\nIn case some files shall not be instrumented consider file or function level exclusion ThreadSanatizers blacklisting, more specific: ThreadSanatizers Sanitizer Special Case List or with ThreadSanatizers no_sanitize(“thread”) and use the option --fsanitize-blacklist.\n\nResulting context:\n\nHigher chance to find data races and deadlocks in production code before deploying it.\nAnalysis result may lack reliability, tool in beta phase stage (in case of ThreadSanatizer).\nOverhead due to production code instrumentation (maintenance of separate branches for instrumented/not instrumented production code, etc.).\nInstrumented code needs more memory per thread (in case of ThreadSanatizer).\nInstrumented code maps a lot virtual address space (in case of ThreadSanatizer).\n\n\n\nCode coverage analysis¶\nContext\nYou have written tests for the library level production code of a ROS2 package (usually refered to as “unit tests”).\nProblem\nYou do not know how much of the production code is exercised during the execution of the tests.\nSolution\nSelect and use a code coverage analysis tool to determine the code coverage.\nForces\n\nIs it possible to integrate the tool with your source code editor?\nIf not web service based: Is it possible to integrate the tool with your continuous integration infrastructure?\nWhat type(s) of coverage measurements (e.g. statement coverage) does the tool support?\n\nExample\n\nC++\ngcov + lcov\ncoveralls.io\n\n\nPython\ncoveralls.io\n\n\n\nResulting context\n\nYou know how much of your production code was exercised during the execution of the unit tests.\nYou have a more or less immediate feedback about the code coverage (editor integration / web service front end).\nYou do not know anything about the quality of your tests. (The only way to figure that out is some kind of review).\n\n\n\n"},{"id":29,"url":"/doc/ros2/Tutorials/Cross-compilation/","title":"Overview","content":"\nOverview¶\n\nOpen Robotics provides pre-built ROS2 packages for multiple platforms, but a number of developers still rely on cross-compilation for different reasons such as:\n\nThe development machine does not match the target system.\nTuning the build for specific core architecture (e.g. setting -mcpu=cortex-a53 -mfpu=neon-fp-armv8 when building for Raspberry Pi3).\nTargeting a different file systems other than the ones supported by the pre-built images released by Open Robotics.\n\n\n\nThis document provides you with details on how to cross-compile the ROS2 software stack as well as provide examples for cross-compiling to systems based on the Arm cores.\n\nNote\nThere are a few ROS2 packages that fail cross-compilation and have to be disabled during the build. See 4. Build section.\n\n\n\nHow does it work ?¶\nCross-compiling simple software (e.g. no dependencies on external libraries) is relatively simple and only requiring a cross-compiler toolchain to be used instead of the native toolchain.\n\nThere are a number of factors which make this process more complex:\n\nThe software being built must support the target architecture. Architecture specific code must be properly isolated and enabled during the build according to the target architecture. Examples include assembly code.\nAll dependencies (e.g. libraries) must be present, either as pre-built packages or also cross-compiled before the target software using them is cross-compiled.\nWhen building software stacks (as opposed to an standalone software) using build tools (e.g. colcon), it is expected from the build tool a mechanism to allow the developer to enable cross-compilation on the underlying build system used by each of software in the stack.\n\n\n\n\n\nCross-compiling ROS2¶\n\nAlthough ROS2 is a rich software stack with a number of dependencies, it primarily uses two different types of packages:\n\nPython based software, which requires no cross-compilation.\nCMake based software, which provides a mechanism to do cross-compilation.\n\n\n\nFurthermore, the ROS2 software stack is built with Colcon which provides a mechanism to forward parameters to the CMake instance used for the individual build of each package/library that is part of the ROS2 distribution.\nWhen building ROS2 natively, the developer is required to download all the dependencies (e.g. Python and other libraries) before compiling the packages that are part of the ROS2 distribution. When cross-compiling, the same approach is required. The developer must first have the target system’s filesystem with all dependencies already installed.\nThe next sections of this document explain in detail the use of cmake-toolchains and the CMAKE_SYSROOT feature to cross-compile ROS2.\n\nCMake toolchain-file¶\nA CMake toolchain-file is a file which defines variables to configure CMake for cross-compilation. The basic entries are:\n\n\nCMAKE_SYSTEM_NAME: the target platform, e.g. linux\nCMAKE_SYSTEM_PROCESSOR: the target architecture, e.g. aarch64 or arm\nCMAKE_SYSROOT: the path to the target file-system\nCMAKE_C_COMPILER: the C cross-compiler, e.g. aarch64-linux-gnu-gcc\nCMAKE_CXX_COMPILER: the C++ cross-compiler, e.g. aarch64-linux-gnu-g++\nCMAKE_FIND_ROOT_PATH: an alternative path used by the find_* command to find the file-system\n\n\nWhen cross-compiling ROS2, the following options are required to be set:\n\n\nCMAKE_FIND_ROOT_PATH: the alternative path used by the find_* command, use it to specify the path to ROS2 /install folder\nCMAKE_FIND_ROOT_PATH_MODE_*: the search strategy for program,package,library, and include, usually: NEVER (look on the host-fs), ONLY (look on sysroot), ONLY (look on sysroot) and ONLY (look on sysroot)\nPYTHON_SOABI: the index name of the python libraries generated by ROS2, e.g. cpython-36m-aarch64-linux-gnu\nTHREADS_PTHREAD_ARG \"0\" CACHE STRING \"Result from TRY_RUN\" FORCE: Force the result of the TRY_RUN cmd to 0 (success) because binaries can not run on the host system.\n\n\nThe toolchain-file is provided to CMake with the -DCMAKE_TOOLCHAIN_FILE=path/to/file parameter. This will also set the CMAKE_CROSSCOMPILING variable to true which can be used by the software being built.\nThe CMAKE_SYSROOT is particularly important for ROS2 as the packages need many dependencies (e.g. python, openssl, opencv, poco, eigen3, ...).\nSetting CMAKE_SYSROOT to a target file-system with all the dependencies installed on it will allow CMake to find them during the cross-compilation.\n\nNote\nYou can find more information on the CMake documentation page.\n\nWhen dowloading the ROS2 source code, a generic toolchain-file is available in the repository ros2/cross_compile/cmake-toolchains which can be downloaded separately. Further examples on using it can be found on the Cross-compiling examples for Arm section.\n\n\nTarget file-system¶\nAs mentioned previously, ROS2 requires different libraries which needs to be provided to cross-compile.\n\nThere are a number of ways to obtain the file-system:\n\ndownloading a pre-built image\ninstalling the dependencies on the target and exporting the file-system (e.g. with sshfs)\nusing qemu + docker (or chroot) to generate the file-system on the host machine.\n\n\n\n\nNote\nYou can find information on how to use Docker + qemu on the next Cross-compiling examples for Arm section.\n\n\n\nBuild process¶\nThe build process is similar to native compilation. The only difference is an extra argument to Colcon to specify the toolchain-file:\ncolcon build --merge-install \\\n    --cmake-force-configure \\\n    --cmake-args \\\n        -DCMAKE_TOOLCHAIN_FILE=\"<path_to_toolchain/toolchainfile.cmake>\"\n\n\nThe toolchain-file provide to CMake the information of the cross-compiler and the target file-system.\nColcon will call CMake with the given toolchain-file on every package of ROS2.\n\n\n\nCross-compiling examples for Arm¶\nAfter downloading the ROS2 source code, you can add cross-compilation assets to the workspace via git clone https://github.com/ros2/cross_compile.git src/ros2/cross_compile. These are working examples on how to cross-compile for Arm cores.\n\nThe following targets are supported:\n\nUbuntu-arm64: To be used with any ARMv8-A based system.\nUbuntu-armhf: To be used with any modern ARMv7-A based system.\n\n\nThese are the main steps:\n\nInstalling development tools\nDownloading ROS2 source code\nDownloading the ROS2 cross-compilation assets\nPreparing the sysroot\nCross-compiling the ROS2 software stack\n\n\n\nThe next sections explains in detail each of these steps.\nFor a quick-setup, have a look at the Automated Cross-compilation.\n\nNote\nThese steps were tested on an Ubuntu 18.04 (Bionic)\n\n\n1. Install development tools¶\nThis step is similar to when building natively. The difference is that some of the libraries and tools are not required because they will be in the sysroot instead.\nThe following packages are required\nsudo apt update && sudo apt install -y \\\n    cmake \\\n    git \\\n    wget \\\n    python3-pip \\\n    qemu-user-static \\\n    g++-aarch64-linux-gnu \\\n    g++-arm-linux-gnueabihf \\\n    pkg-config-aarch64-linux-gnu\n\npython3 -m pip install -U \\\n    vcstool \\\n    colcon-common-extensions\n\n\n\nNote\nYou can install vcstool and colcon-common-extensions via pip. This\nmeans you are not required to add extra apt repositories.\n\nDocker is used to build the target environment. Follow the official documentation for the installation.\n\n\n2. Download ROS2 source code¶\nThen create a workspace and download the ROS2 source code:\nmkdir -p ~/cc_ws/ros2_ws/src\ncd ~/cc_ws/ros2_ws\nwget https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos\nvcs-import src < ros2.repos\ngit clone https://github.com/ros2/cross_compile.git src/ros2/cross_compile\ncd ..\n\n\n\n\n3. Prepare the sysroot¶\nBuild an arm Ubuntu image with all the ROS2 dependencies using Docker and qemu:\nCopy the qemu-static binary to the workspace.\nIt will be used to install the ros2 dependencies on the target file-system with docker.\nmkdir qemu-user-static\ncp /usr/bin/qemu-*-static qemu-user-static\n\n\nThe standard setup process of ROS2 is run inside an arm docker. This is possible thanks to qemu-static, which will emulate an arm machine. The base image used is an Ubuntu Bionic from Docker Hub.\ndocker build -t aarch64_ros2:latest -f ros2_ws/src/ros2/cross_compile/sysroot/Dockerfile_ubuntu_arm64 .\ndocker run --name aarch64_sysroot aarch64_ros2:latest\n\n\nExport the resulting container to a tarball and extract it:\ndocker container export -o sysroot_docker.tar aarch64_sysroot\nmkdir sysroot_docker\ntar -C sysroot_docker -xf sysroot_docker.tar lib usr opt\n\n\nThis container can be used later as virtual target to run the created file-system and run the demo code.\n\n\n4. Build¶\nSet the variables used by the generic toolchain-file\nexport TARGET_ARCH=aarch64\nexport TARGET_TRIPLE=aarch64-linux-gnu\nexport CC=/usr/bin/$TARGET_TRIPLE-gcc\nexport CXX=/usr/bin/$TARGET_TRIPLE-g++\nexport CROSS_COMPILE=/usr/bin/$TARGET_TRIPLE-\nexport SYSROOT=~/cc_ws/sysroot_docker\nexport ROS2_INSTALL_PATH=~/cc_ws/ros2_ws/install\nexport PYTHON_SOABI=cpython-36m-$TARGET_TRIPLE\n\n\nThe following packages still cause errors during the cross-compilation (under investigation) and must be disabled for now.\ntouch \\\n    ros2_ws/src/ros2/rviz/COLCON_IGNORE \\\n    ros2_ws/src/ros2/demos/intra_process_demo/COLCON_IGNORE \\\n    ros2_ws/src/ros2/demos/image_tools/COLCON_IGNORE \\\n    ros2_ws/src/ros2/robot_state_publisher/COLCON_IGNORE \\\n    ros2_ws/src/ros-visualization/COLCON_IGNORE\n\n\nThen, start a build with colcon specifying the toolchain-file:\ncd ros2_ws\n\ncolcon build --merge-install \\\n    --cmake-force-configure \\\n    --cmake-args \\\n        -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON \\\n        -DCMAKE_TOOLCHAIN_FILE=\"$(pwd)/src/ros2/cross_compile/cmake-toolchains/generic_linux.cmake\" \\\n        -DSECURITY=ON\n\n\nDone! The install and build directories will contain the cross-compiled assets.\n\n\n\nAutomated Cross-compilation¶\nAll the steps above are also included into a Dockerfile and can be used for automation/CI.\nFirst, download the dockerfile and build the image:\nwget https://raw.githubusercontent.com/ros2/cross_compile/master/Dockerfile_cc_for_arm\ndocker build -t ros2-crosscompiler:latest - < Dockerfile_cc_for_arm\n\n\nNow run the image with:\n(it will take a while !)\ndocker run -it --name ros2_cc \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    ros2-crosscompiler:latest\n\n\n..note:: The -v /var/run/docker.sock allow us to use Docker inside Docker.\nThe result of the build will be inside the ros2_ws directory, which can be exported with:\ndocker cp ros2_cc:/root/cc_ws/ros2_ws .\n\n\n\n\nCross-compiling against a pre-built ROS2¶\nIt is possible to cross-compile your packages against a pre-built ROS2. The steps are similar to the previous Cross-compiling examples for Arm section, with the following modifications:\nInstead of downloading the ROS2 stack, just populate your workspace with your package (ros2 examples on this case) and the cross-compilation assets:\nmkdir -p ~/cc_ws/ros2_ws/src\ncd ~/cc_ws/ros2_ws/src\ngit clone https://github.com/ros2/examples.git\ngit clone https://github.com/ros2/cross_compile.git\ncd ..\n\n\nGenerate and export the file-system as described in 3. Prepare the sysroot, but with the provided Dockerfile_ubuntu_arm64_prebuilt. These _prebuilt Dockerfile will use the binary packages to install ROS2 instead of building from source.\nModify the environment variable ROS2_INSTALL_PATH to point to the installation directory:\nexport ROS2_INSTALL_PATH=~/cc_ws/sysroot_docker/opt/ros/crystal\n\n\nSource the setup.bash script on the target file-system:\nsource $ROS2_INSTALL_PATH/setup.bash\n\n\nThen, start a build with Colcon specifying the toolchain-file:\ncolcon build \\\n    --merge-install \\\n    --cmake-force-configure \\\n    --cmake-args \\\n        -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON \\\n        -DCMAKE_TOOLCHAIN_FILE=\"$(pwd)/src/cross_compile/cmake-toolchains/generic_linux.cmake\"\n\n\n\n\nRun on the target¶\nCopy the file-system on your target or use the previously built docker image:\ndocker run -it --rm -v `pwd`/ros2_ws:/ros2_ws aarch64_ros2:latest\n\n\nSource the environment:\nsource /ros2_ws/install/local_setup.bash\n\n\nRun some of the C++ or python examples:\nros2 run demo_nodes_cpp listener &\nros2 run demo_nodes_py talker\n\n\n\n"},{"id":30,"url":"/doc/ros2/Tutorials/RQt-Overview-Usage/","title":"Overview and Usage of RQt","content":"\nOverview and Usage of RQt¶\n\nTable of Contents\n\nOverview\nSystem setup\nInstalling From Debian\nBuilding From Source\n\n\nRQt Components Structure\nAdvantage of RQt framework\nFurther Reading\n\n\n\nOverview¶\nRQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins.\nOne can run all the existing GUI tools as dockable windows within RQt!\nThe tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout.\nYou can run any RQt tools/plugins easily by:\nrqt\n\n\nThis GUI allows you to choose any available plugins on your system.\nYou can also run plugins in standalone windows.\nFor example, RQt Python Console:\nros2 run rqt_py_console rqt_py_console\n\n\nUsers can create their own plugins for RQt with either Python or C++.\nOver 20 plugins were created in ROS 1 and these plugins are currently being ported to ROS 2 (as of Dec 2018, more info).\n\n\nSystem setup¶\n\nInstalling From Debian¶\nsudo apt install ros-$ROS_DISTRO-rqt*\n\n\n\n\nBuilding From Source¶\n\n\nSee Building RQt from Source.\n\n\n\nRQt Components Structure¶\nRQt consists of three metapackages:\n\nrqt - core infrastucture modules.\n\n\nrqt_common_plugins - Backend tools for building tools.\nTODO: as of Dec 2018 this metapackage isn’t available in ROS 2 since not all plugins it contains have been ported yet.\n\n\n\n\nrqt_robot_plugins - Tools for interacting with robots during runtime.\nTODO: as of Dec 2018 this metapackage isn’t available in ROS 2 since not all plugins it contains have been ported yet.\n\n\n\n\n\n\nAdvantage of RQt framework¶\nCompared to building your own GUIs from scratch:\n\nStandardized common procedures for GUI (start-shutdown hook, restore previous states).\nMultiple widgets can be docked in a single window.\nEasily turn your existing Qt widgets into RQt plugins.\nExpect support at ROS Answers (ROS community website for the questions).\n\nFrom system architecture’s perspective:\n\nSupport multi-platform (basically wherever QT and ROS run) and multi-language (Python, C++).\nManageable lifecycle: RQt plugins using common API makes maintainance & reuse easier.\n\n\n\nFurther Reading¶\n\nROS 2 Discourse announcment of porting to ROS2).\n\nRQt for ROS 1 documentation.\n\nBrief overview of RQt (from a Willow Garage intern blog post).\n\n\n\n\n"},{"id":31,"url":"/doc/ros2/Tutorials/Python-Programming/","title":"Python Programming in ROS 2","content":"\nPython Programming in ROS 2¶\n\nTable of Contents\n\nBackground\nInstall\nRun the examples\nCommunication with nodes using different ROS client libraries\n\n\n\nBackground¶\nOne of the most popular features of ROS 1 is the ability of writing robot applications in a variety of languages. Starting with Alpha 4, ROS 2 provides a Python API that can be used for communicating with other nodes written in different languages.\n\n\nInstall¶\nThe rclpy module enables developers to use the ROS 2 API from Python. As of Alpha 4, rclpy is still under development and its API might change, but for now the basics (publishers and subscriptions) can be accessed from Python.\nrclpy is part of the standard ROS 2 distribution, so it’ll be installed alongside the rest of the ROS 2 packages.\n\n\nRun the examples¶\nThe two classic ROS 2 examples of a “talker” and a “listener” have been implemented in Python using rclpy. The source code is available here.\nOpen two terminals, source the appropriate setup.* / local_setup.* file in the terminals, and run ros2 run demo_nodes_py talker in one and ros2 run demo_nodes_py listener in the other.\nOnce executed you should see the following on the terminal running the listener:\nI heard: [Hello World: 1]\nI heard: [Hello World: 2]\nI heard: [Hello World: 3]\nI heard: [Hello World: 4]\nI heard: [Hello World: 5]\nI heard: [Hello World: 6]\nI heard: [Hello World: 7]\nI heard: [Hello World: 8]\nI heard: [Hello World: 9]\nI heard: [Hello World: 10]\n\n\n\n\nCommunication with nodes using different ROS client libraries¶\nSince rclpy uses the underlying ROS 2 infrastructure, Python programs that use rclpy can also communicate with applications written in C++, even if they use a different DDS vendor and are running on a different operating system.\n\n\n"}]