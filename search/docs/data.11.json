[{"id":44,"url":"/doc/ros2/Tutorials/RQt-Port-Plugin-Windows/","title":"Porting RQt plugins to Windows","content":"\nPorting RQt plugins to Windows¶\n\nTable of Contents\n\nRQt Porting examples\nConsiderations for Windows 10\nTroubles with TinyXML version 1\nCode that uses __cplusplus and code that requires pluginlib\nLocations of build artifacts (before install)\nCompiler and linker flags\n\n\n\n\nRQt has not been historically supported on Windows, but compatibility is happening, slowly.\n\nRQt Porting examples¶\nMicrosoft pushed an effort to port much of ROS to Windows, their repos are a good resource for necessary changes.\nThey live at the ms-iot organization with branches called init-windows.\nFor example: https://github.com/ms-iot/qt_gui_core/tree/init_windows\nHere is the ROS 2 port of qt_gui_core.\nHere is the ROS 2 port of python_qt_binding.\n\n\nConsiderations for Windows 10¶\n\nTroubles with TinyXML version 1¶\nI could not successfully use TinyXML.\nI upgraded to TinyXML-2 where needed.\nIt’s a pretty straight forward change.\nCheckout this PR for an example of porting to TinyXML-2.\n\n\nCode that uses __cplusplus and code that requires pluginlib¶\nIn some places, notably in the ROS 2 port of pluginlib, there is use of the __cplusplus flag.\nUnfortunately on Windows Visual Studio does not set this flag correctly regardless of the C++ standard that is actually being used.\nSee this page for more information.\nTo set it, you need to add the compile option /Zc:__cplusplus.\nFor example, in CMake you could do something like this:\ntarget_compile_options(${PROJECT_NAME} PUBLIC \"/Zc:__cplusplus\")\n\n\n\n\nLocations of build artifacts (before install)¶\nThis only came up during when building qt_gui_cpp.\nIn that package, a custom command depends on a target library in another part of the package.\nHowever, that library isn’t installed until build is complete. Windows builds in a ${configuration} directory.\nFor example:\nOn Linux, qt_gui_cpp.a would be built in:\n<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/\nBut on Windows qt_gui_cpp.lib is built in\n<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/Release\nFor compatibility across platforms in this situation, use CMake generator expressions.\nHowever, when you need a library to link against be sure to use $<TARGET_LINKER_FILE:_target> instead of $<TARGET_FILE:_target>.\nThe latter will find .dll files, which cannot be linked against on Windows.\nSee an example here.\n\n\nCompiler and linker flags¶\nIn general when porting to Windows, many packages might make use of additional compiler flags.\nYou can find the Windows compiler flags on Microsoft’s documentation.\nThe C++ compiler is called cl.exe.\nFor linker flags see Microsoft’s documentation.\nThe linker program is called link.exe.\nHowever, CMake actually provides many of these options in variables.\nThis StackOverflow page contains a good example of how to see all the CMake variables available in a script.\n\n\n\n"},{"id":45,"url":"/doc/ros2/Tutorials/Rosbag-with-ROS1-Bridge/","title":"Recording and playback of topic data with rosbag using the ROS 1 bridge","content":"\nRecording and playback of topic data with rosbag using the ROS 1 bridge¶\nThis tutorial is a follow up to the Bridge communication between ROS 1 and ROS 2 demo as can be found listed with the other demos, and in the following it is assumed you have completed that tutorial already.\nThe ros1_bridge can either be installed from binary packages or built from source; both work for these examples.\nWhat follows is a series of additional examples, like that ones that come at the end of the aforementioned Bridge communication between ROS 1 and ROS 2 demo.\n\nRecording topic data with rosbag and ROS 1 Bridge¶\nIn this example, we’ll be using the cam2image demo program that comes with ROS 2 and a Python script to emulate a simple turtlebot-like robot’s sensor data so that we can bridge it to ROS 1 and use rosbag to record it.\nFirst we’ll run a ROS 1 roscore in a new shell:\n# Shell A:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nroscore\n\n\nThen we’ll run the ROS 1 <=> ROS 2 dynamic_bridge with the --bridge-all-topics option (so we can do rostopic list and see them) in another shell:\n# Shell B:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nexport ROS_MASTER_URI=http://localhost:11311\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n\n\nRemember to replace <workspace-with-bridge> with the path to where you either extracted the ROS 2 binary or where you built ROS 2 from source.\n\nNow we can start up the ROS 2 programs that will emulate our turtlebot-like robot.\nFirst we’ll run the cam2image program with the -b option so it doesn’t require a camera to work:\n# Shell C:\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nros2 run image_tools cam2image -- -b\n\n\nTODO: use namespaced topic names\nThen we’ll run a simple Python script to emulate the odom and imu_data topics from a Kobuki base.\nI would use the more accurate ~sensors/imu_data topic name for the imu data, but we don’t have namespace support just yet in ROS 2 (it’s coming!).\nPlace this script in a file called emulate_kobuki_node.py:\n#!/usr/bin/env python3\n\nimport sys\nimport time\n\nimport rclpy\n\nfrom nav_msgs.msg import Odometry\nfrom sensor_msgs.msg import Imu\n\ndef main():\n    rclpy.init(args=sys.argv)\n\n    node = rclpy.create_node('emulate_kobuki_node')\n\n    imu_publisher = node.create_publisher(Imu, 'imu_data')\n    odom_publisher = node.create_publisher(Odometry, 'odom')\n\n    imu_msg = Imu()\n    odom_msg = Odometry()\n    counter = 0\n    while True:\n        counter += 1\n        now = time.time()\n        if (counter % 50) == 0:\n            odom_msg.header.stamp.sec = int(now)\n            odom_msg.header.stamp.nanosec = int(now * 1e9) % 1000000000\n            odom_publisher.publish(odom_msg)\n        if (counter % 100) == 0:\n            imu_msg.header.stamp.sec = int(now)\n            imu_msg.header.stamp.nanosec = int(now * 1e9) % 1000000000\n            imu_publisher.publish(imu_msg)\n            counter = 0\n        time.sleep(0.001)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n\n\nYou can run this python script in a new ROS 2 shell:\n# Shell D:\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\npython3 emulate_kobuki_node.py\n\n\n\nNow that all the data sources and the dynamic bridge are running, we can look at the available topics in a new ROS 1 shell:\n# Shell E:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nrostopic list\n\n\nYou should see something like this:\n% rostopic list\n/image\n/imu_data\n/odom\n/rosout\n/rosout_agg\n\n\nWe can now record this data with rosbag record in the same shell:\n# Shell E:\nrosbag record /image /imu_data /odom\n\n\nAfter a few seconds you can Ctrl-c the rosbag command and do an ls -lh to see how big the file is, you might see something like this:\n% ls -lh\ntotal 0\n-rw-rw-r-- 1 william william  12M Feb 23 16:59 2017-02-23-16-59-47.bag\n\n\nThough the file name will be different for your bag (since it is derived from the date and time).\n\n\nPlaying back topic data with rosbag and ROS 1 Bridge¶\nNow that we have a bag file you can use any of the ROS 1 tools to introspect the bag file, like rosbag info <bag file>, rostopic list -b <bag file>, or rqt_bag <bag file>.\nHowever, we can also playback bag data into ROS 2 using rosbag play and the ROS 1 <=> ROS 2 dynamic_bridge.\nFirst close out all the shells you opened for the previous tutorial, stopping any running programs.\nThen in a new shell start the roscore:\n# Shell P:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nroscore\n\n\nThen run the dynamic_bridge in another shell:\n# Shell Q:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nexport ROS_MASTER_URI=http://localhost:11311\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n\n\nThen play the bag data back with rosbag play in another new shell, using the --loop option so that we don’t have to keep restarting it for short bags:\n# Shell R:\n. /opt/ros/kinetic/setup.bash\n# Or, on OSX, something like:\n# . ~/ros_catkin_ws/install_isolated/setup.bash\nrosbag play --loop path/to/bag_file\n\n\nMake sure to replace path/to/bag_file with the path to the bag file you want to playback.\n\nNow that the data is being played back and the bridge is running we can see the data coming across in ROS 2.\n# Shell S:\n. /opt/ros/ardent/setup.bash\n# Or, if building ROS2 from source:\n# . <workspace-with-bridge>/install/setup.bash\nros2 topic list\nros2 topic echo /odom\n\n\nYou should see something like:\n% ros2 topic list\n/clock\n/image\n/imu_data\n/odom\n/parameter_events\n\n\nYou can also see the image being played from the bag by using the showimage tool:\nros2 run image_tools showimage\n\n\n\n\n"},{"id":46,"url":"/doc/ros2/Contributing/Inter-Sphinx-Support/","title":"Using Sphinx for cross-referencing packages","content":"\nUsing Sphinx for cross-referencing packages¶\n\nTable of Contents\n\nShowing all links of an Intersphinx mapping file\nLinking to other sites using Intersphinx\nExamples of intersphinx in action\n\n\nThis is page provides a quick guide on how you can cross-reference packages documentation within rosindex using Sphinx.\nInventory files must be added to ROSIndex Sphinx’s conf.py file found here. Note that the URI added to the configuration file must point to the directory where the .inv file is rather than to the file itself (i.e: http://docs.ros.org/independent/api/catkin_pkg instead of http://docs.ros.org/independent/api/catkin_pkg/objects.inv).\n\nShowing all links of an Intersphinx mapping file¶\n(Partially borrowed from here).\nTo show all Intersphinx links and their targets of an Intersphinx mapping file, either local or remote, run:\npython -msphinx.ext.intersphinx \"url-or-path-to-inv-file\"\n\n\nThis is helpful when searching for the root cause of a broken Intersphinx link in a documentation project.\n\n\nLinking to other sites using Intersphinx¶\n(Partially borrowed from here).\n\nYou may supply an explicit title and reference target: :role:\\`title <target>\\` will refer to target, but the link text will be title.\nIf you prefix the content with !, no reference/hyperlink will be created.\nIf you prefix the content with ~, the link text will only be the last component of the target. For example, :py:meth:\\`~Queue.Queue.get\\` will refer to Queue.Queue.get but only display get as the link text.\n\n\n\nExamples of intersphinx in action¶\nLinks to source code can be created as follows:\n\nNote\nClass vcstools.VcsClient implements the vcstools.VcsClient.checkout() method.\n\nClass vcstools.VcsClient implements the vcstools.VcsClient.checkout() method.\n\nLinks to documentation pages:\n\nNote\nRefer to vcstools Developer's Guide document.\n\nRefer to vcstools Developer's Guide document.\n\nLinks to other pages in this documentation:\n\nNote\nSee the installation page.\n\nSee the installation page.\n\n\n"},{"id":47,"url":"/doc/ros2/Installation/Linux-Install-Binary/","title":"Installing ROS 2 on Linux","content":"\nInstalling ROS 2 on Linux¶\n\nTable of Contents\n\nSystem Requirements\nAdd the ROS 2 apt repository\nDownloading ROS 2\nInstalling and initializing rosdep\nInstalling the missing dependencies\nInstalling the python3 libraries\n\n\nInstall additional DDS implementations (optional)\nAdlink OpenSplice\nRTI Connext\n\n\nTry some examples\nUsing the ROS 1 bridge\n\n\n\n\nThis page explains how to install ROS 2 on Linux from a pre-built binary package.\nAs of Beta 2 there are also Debian packages available.\n\nSystem Requirements¶\nWe support Ubuntu Linux Bionic Beaver (18.04) and Ubuntu Xenial Xerus (16.04) on 64-bit x86 and 64-bit ARM.\nNote: Ardent and beta versions supported Ubuntu Xenial Xerus 16.04.\n\n\nAdd the ROS 2 apt repository¶\nSee the development instructions.\n\n\nDownloading ROS 2¶\n\nGo the releases page\n\nDownload the latest package for Linux; let’s assume that it ends up at ~/Downloads/ros2-crystal-linux-x86_64.tar.bz2.\n\nNote: there may be more than one binary download option which might cause the file name to differ.\n\n\nUnpack it:\nmkdir -p ~/ros2_install\ncd ~/ros2_install\ntar xf ~/Downloads/ros2-crystal-linux-x86_64.tar.bz2\n\n\n\n\n\n\nInstalling and initializing rosdep¶\nsudo apt install -y python-rosdep\nrosdep init\nrosdep update\n\n\n\n\nInstalling the missing dependencies¶\nSet your rosdistro according to the release you downloaded.\nCHOOSE_ROS_DISTRO=crystal # or bouncy\nrosdep install --from-paths ros2-linux/share --ignore-src --rosdistro $CHOOSE_ROS_DISTRO -y --skip-keys \"console_bridge fastcdr fastrtps libopensplice67 libopensplice69 osrf_testing_tools_cpp poco_vendor rmw_connext_cpp rosidl_typesupport_connext_c rosidl_typesupport_connext_cpp rti-connext-dds-5.3.1 tinyxml_vendor tinyxml2_vendor urdfdom urdfdom_headers\"\n\n\n\nOptional: if you want to use the ROS 1<->2 bridge, then you must also install ROS 1.\nFollow the normal install instructions: http://wiki.ros.org/kinetic/Installation/Ubuntu\n\n\nInstalling the python3 libraries¶\nsudo apt install -y libpython3-dev\n\n\n\n\n\nInstall additional DDS implementations (optional)¶\nROS 2 builds on top of DDS.\nIt is compatible with multiple DDS or RTPS (the DDS wire protocol) vendors.\nThe package you downloaded has been built with optional support for multiple vendors: eProsima FastRTPS, Adlink OpenSplice, and (as of ROS 2 Bouncy) RTI Connext as the middleware options.\nRun-time support for eProsima’s Fast RTPS is included bundled by default.\nIf you would like to use one of the other vendors you will need to install their software separately.\n\nAdlink OpenSplice¶\nTo use OpenSplice you can install a Debian package built by OSRF.\nCrystal and above:\nsudo apt update && sudo apt install -q -y \\\n    libopensplice69\n\n\nBouncy and earlier:\nsudo apt update && sudo apt install -q -y \\\n    libopensplice69\n\n\n\n\nRTI Connext¶\nTo use RTI Connext you will need to have obtained a license from RTI.\nAdd the following line to your .bashrc file pointing to your copy of the license (and source it).\nexport RTI_LICENSE_FILE=path/to/rti_license.dat\n\n\nYou can install a Debian package of RTI Connext built by OSRF.\nYou will need to accept a license from RTI.\nsudo apt update && sudo apt install -q -y \\\n    rti-connext-dds-5.3.1\n\n\nIf you want to install the Connext DDS-Security plugins please refer to this page.\n\n\n\nTry some examples¶\nIn one terminal, source the setup file and then run a talker:\n. ~/ros2_install/ros2-linux/setup.bash\nros2 run demo_nodes_cpp talker\n\n\nIn another terminal source the setup file and then run a listener:\n. ~/ros2_install/ros2-linux/setup.bash\nros2 run demo_nodes_cpp listener\n\n\nYou should see the talker saying that it’s Publishing messages and the listener saying I heard those messages.\nHooray!\nIf you have installed support for an optional vendor, see this page for details on how to use that vendor.\nSee the demos for other things to try, including how to run the talker-listener example in Python.\n\nUsing the ROS 1 bridge¶\nIf you have ROS 1 installed, you can try the ROS 1 bridge, by first sourcing your ROS 1 setup file.\nWe’ll assume that it is /opt/ros/melodic/setup.bash in the following.\nIf you haven’t already, start a roscore:\n. /opt/ros/melodic/setup.bash\nroscore\n\n\nIn another terminal, start the bridge:\n. /opt/ros/melodic/setup.bash\n. ~/ros2_install/ros2-linux/setup.bash\nros2 run ros1_bridge dynamic_bridge\n\n\nFor more information on the bridge, read the tutorial.\n\n\n\n"}]