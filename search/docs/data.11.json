[{"id":44,"url":"/doc/ros2/Related-Projects/Intel-ROS2-Projects/","title":"Intel ROS2 Projects","content":"\nIntel ROS2 Projects¶\nIntel® Robotics Open Source Project (Intel® ROS Project) to enable object detection/location/tracking, people detection, vehicle detection, industry robot arm grasp point analysis with kinds of Intel technologies and platforms, including CPU, GPU, Intel® Movidius™ NCS optimized deep learning backend, FPGA, Intel® RealSense™ camera, etc.\n\nKey Projects¶\nWe are working on below ROS2 projects and publish source code through https://github.com/intel/ or ROS2 github repo gradually.\n\nROS2 OpenVINO: ROS2 package for Intel® Visual Inference and Neural Network Optimization Toolkit to develop multiplatform computer vision solutions.\nROS2 RealSense Camera: ROS2 package for Intel® RealSense™ D400 serial cameras\nROS2 Movidius NCS: ROS2 package for object detection with Intel® Movidius™ Neural Computing Stick (NCS).\nROS2 Object Messages: ROS2 messages for object.\nROS2 Object Analytics: ROS2 package for object detection, tracking and 2D/3D localization.\nROS2 Message Filters: ROS2 package for message synchronization with time stamp.\nROS2 CV Bridge: ROS2 package to bridge with openCV.\nROS2 Object Map: ROS2 package to mark tag of objects on map when SLAM based on information provided by ROS2 object analytics.\nROS2 Moving Object: ROS2 package to provide object motion information (like object velocity on x, y, z axis) based on information provided by ROS2 object analytics.\nROS2 Grasp Library: Coming soon. ROS2 package for grasp position analysis, and compatible with MoveIt grasp interfaces.\n\n\n\nReference¶\nROS components at: http://wiki.ros.org/IntelROSProject shows the relationship among those packages, which also applies to ROS2.\n\n\n"},{"id":45,"url":"/doc/ros2/Tutorials/Rosidl-Tutorial/","title":"Introduction to msg and srv interfaces","content":"\nIntroduction to msg and srv interfaces¶\nINCOMPLETE: this is a draft of an upcoming tutorial for creating and using custom ROS interfaces.\nDisclaimer: The code provided is to support the explanation, it is likely outdated and should not be expected to compile as is\n\nmsg: msg files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages.\nsrv: an srv file describes a service. It is composed of two parts: a request and a response. The request and response are message declarations.\n\nmsgs are just simple text files with a field type and field name per line. The field types you can use are:\n\nint8, int16, int32, int64 (plus uint*)\nfloat32, float64\nstring\nother msg files\nvariable-length array[], fixed-length array[C], bounded-length array[<=C]\n\nHere is an example of a msg that uses a string primitive, and two other msgs:\nstring child_frame_id\ngeometry_msgs/PoseWithCovariance pose\ngeometry_msgs/TwistWithCovariance twist\n\n\nsrv files are just like msg files, except they contain two parts: a request and a response. The two parts are separated by a ‘—’ line. Here is an example of a srv file:\nfloat64 A\nfloat64 B\n---\nfloat64 Sum\n\n\nIn the above example, A and B are the request, and Sum is the response.\nmsg files are stored in the msg directory of a package, and srv files are stored in the srv directory.\nThese are just simple examples.\nFor more information about how to create msg and srv files please refer to About ROS Interfaces.\n\nCreating a msg package¶\nNOTE: only ament_cmake packages can generate messages currently (not ament_python packages).\nFor this tutorial we will use the packages stored in the rosidl_tutorials repository.\ncd ~/ros2_overlway_ws/src\ngit clone -b rosidl_tutorials https://github.com/ros2/tutorials.git\ncd rosidl_tutorials/rosidl_tutorials_msgs\n\n\n\nCreating a msg file¶\nHere we will create a message meant to carry information about an individual.\nOpen msg/Contact.msg and you will see:\nbool FEMALE=true\nbool MALE=false\n\nstring first_name\nstring last_name\nbool gender\nuint8 age\nstring address\n\n\nThis message is composed of 5 fields:\n\nfirst_name: of type string\nlast_name: of type string\ngender: of type bool, that can be either MALE or FEMALE\nage: of type uint8\naddress: of type string\n\nThere’s one more step, though. We need to make sure that the msg files are turned into source code for C++, Python, and other languages.\n\n\nBuilding msg files¶\nOpen the package.xml, and uncomment these two lines:\n<buildtool_depend>rosidl_default_generators</buildtool_depend>\n\n<exec_depend>rosidl_default_runtime</exec_depend>\n\n\nNote that at build time, we need “rosidl_default_generators”, while at runtime, we only need “rosidl_default_runtime”.\nOpen the CMakeLists.txt and make sure that the following lines are uncommented.\nFind the package that generates message code from msg/srv files:\nfind_package(rosidl_default_generators REQUIRED)\n\n\nDeclare the list of messages you want to generate:\nset(msg_files\n  \"msg/Contact.msg\"\n)\n\n\nBy adding the .msg files manually, we make sure that CMake knows when it has to reconfigure the project after you add other .msg files.\nGenerate the messages:\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n)\n\n\nAlso make sure you export the message runtime dependency:\nament_export_dependencies(rosidl_default_runtime)\n\n\nNow you’re ready to generate source files from your msg definition.\n\n\nCreating an srv file¶\nWe will now add a srv declaration to our package.\nOpen the srv/AddTwoFloats.srv file and paste this srv declaration:\nfloat64 a\nfloat64 b\n---\nfloat64 sum\n\n\n\n\nBuilding srv files¶\nDeclare the service in the CMakeLists.txt:\nset(srv_files\n  \"srv/AddTwoFloats.srv\")\n\n\nModify the existing call to rosidl_generate_interfaces to generate the service in addition to the messages:\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  ${srv_files}\n)\n\n\n\n\n\nUsing custom messages¶\n\nUsing msg/srv from other packages¶\nLet’s write a C++ node using the Contact.msg we created in the previous section.\nGo to the rosidl_tutorials package and open the src/publish_contact.cpp file.\n#include <iostream>\n#include <memory>\n\n#include \"rclcpp/rclcpp.hpp\"\n\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nusing namespace std::chrono_literals;\n\nclass ContactPublisher : public rclcpp::Node\n{\npublic:\n  ContactPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    contact_publisher_ = this->create_publisher<rosidl_tutorials_msgs::msg::Contact>(\"contact\");\n\n    auto publish_msg = [this]() -> void {\n        auto msg = std::make_shared<rosidl_tutorials_msgs::msg::Contact>();\n\n        msg->first_name = \"John\";\n        msg->last_name = \"Doe\";\n        msg->age = 30;\n        msg->gender = msg->MALE;\n        msg->address = \"unknown\";\n\n        std::cout << \"Publishing Contact\\nFirst:\" << msg->first_name <<\n          \"  Last:\" << msg->last_name << std::endl;\n\n        contact_publisher_->publish(msg);\n      };\n    timer_ = this->create_wall_timer(1s, publish_msg);\n  }\n\nprivate:\n  rclcpp::Publisher<rosidl_tutorials_msgs::msg::Contact>::SharedPtr contact_publisher_;\n  rclcpp::timer::TimerBase::SharedPtr timer_;\n};\n\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n\n  auto publisher_node = std::make_shared<ContactPublisher>();\n\n  rclcpp::spin(publisher_node);\n\n  return 0;\n}\n\n\n\nThe code explained¶\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nHere we include the header of the message that we want to use.\nContactPublisher()\n: Node(\"address_book_publisher\")\n{\n\n\nHere we define a node\nauto publish_msg = [this]() -> void {\n\n\nA publish_msg function to send our message periodically\nauto msg = std::make_shared<rosidl_tutorials_msgs::msg::Contact>();\n\n msg->first_name = \"John\";\n msg->last_name = \"Doe\";\n msg->age = 30;\n msg->gender = msg->MALE;\n msg->address = \"unknown\";\n\n\nWe create a Contact message and populate its fields.\nstd::cout << \"Publishing Contact\\nFirst:\" << msg->first_name <<\n  \"  Last:\" << msg->last_name << std::endl;\n\ncontact_publisher_->publish(msg);\n\n\nFinally we publish it\ntimer_ = this->create_wall_timer(1s, publish_msg);\n\n\nCreate a 1second timer to call our publish_msg function every second\nNow let’s build it!\nTo use this message we need to declare a dependency on rosidl_tutorials_msgs in the package.xml:\n<build_depend>rosidl_tutorials_msgs</build_depend>\n\n<exec_depend>rosidl_tutorials_msgs</exec_depend>\n\n\nAnd also in the CMakeLists.txt:\nfind_package(rosidl_tutorials_msgs REQUIRED)\n\n\nAnd finally we must declare the message package as a target dependency for the executable.\nament_target_dependencies(publish_contact\n  \"rclcpp\"\n  \"rosidl_tutorials_msgs\"\n)\n\n\n\n\n\nUsing msg/srv from the same package¶\nWhile most of the time messages are declared in interface packages, it can be convenient to declare, create and use messages all in the one package.\nWe will create a message in our rosidl_tutorials package.\nCreate a msg directory in the rosidl_tutorials package and AddressBook.msg inside that directory.\nIn that msg paste:\nrosidl_tutorials_msgs/Contact[] address_book\n\n\nAs you can see we define a message based on the Contact message we created earlier.\nTo generate this message we need to declare a dependency on this package in the package.xml:\n<build_depend>rosidl_tutorials_msgs</build_depend>\n\n<exec_depend>rosidl_tutorials_msgs</exec_depend>\n\n\nAnd in the CMakeLists.txt:\nfind_package(rosidl_tutorials_msgs REQUIRED)\n\nset(msg_files\n  \"msg/AddressBook.msg\"\n)\n\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  DEPENDENCIES rosidl_tutorials_msgs\n)\n\n\nNow we can start writing code that uses this message.\nOpen src/publish_address_book.cpp:\n#include <iostream>\n#include <memory>\n\n#include \"rclcpp/rclcpp.hpp\"\n\n#include \"rosidl_tutorials/msg/address_book.hpp\"\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\nusing namespace std::chrono_literals;\n\nclass AddressBookPublisher : public rclcpp::Node\n{\npublic:\n  AddressBookPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    address_book_publisher_ =\n      this->create_publisher<rosidl_tutorials::msg::AddressBook>(\"address_book\");\n\n    auto publish_msg = [this]() -> void {\n        auto msg = std::make_shared<rosidl_tutorials::msg::AddressBook>();\n        {\n          rosidl_tutorials_msgs::msg::Contact contact;\n          contact.first_name = \"John\";\n          contact.last_name = \"Doe\";\n          contact.age = 30;\n          contact.gender = contact.MALE;\n          contact.address = \"unknown\";\n          msg->address_book.push_back(contact);\n        }\n        {\n          rosidl_tutorials_msgs::msg::Contact contact;\n          contact.first_name = \"Jane\";\n          contact.last_name = \"Doe\";\n          contact.age = 20;\n          contact.gender = contact.FEMALE;\n          contact.address = \"unknown\";\n          msg->address_book.push_back(contact);\n        }\n\n        std::cout << \"Publishing address book:\" << std::endl;\n        for (auto contact : msg->address_book) {\n          std::cout << \"First:\" << contact.first_name << \"  Last:\" << contact.last_name <<\n            std::endl;\n        }\n\n        address_book_publisher_->publish(msg);\n      };\n    timer_ = this->create_wall_timer(1s, publish_msg);\n  }\n\nprivate:\n  rclcpp::Publisher<rosidl_tutorials::msg::AddressBook>::SharedPtr address_book_publisher_;\n  rclcpp::timer::TimerBase::SharedPtr timer_;\n};\n\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  auto publisher_node = std::make_shared<AddressBookPublisher>();\n\n  rclcpp::spin(publisher_node);\n\n  return 0;\n}\n\n\n\nThe code explained¶\n#include \"rosidl_tutorials/msg/address_book.hpp\"\n\n\nWe include the header of our newly created AddressBook msg.\n#include \"rosidl_tutorials_msgs/msg/contact.hpp\"\n\n\nHere we include the header of the Contact msg in order to be able to add contacts to our address_book.\nusing namespace std::chrono_literals;\n\nclass AddressBookPublisher : public rclcpp::Node\n{\npublic:\n  AddressBookPublisher()\n  : Node(\"address_book_publisher\")\n  {\n    address_book_publisher_ =\n      this->create_publisher<rosidl_tutorials::msg::AddressBook>(\"address_book\");\n\n\nWe create a node and an AddressBook publisher.\nauto publish_msg = [this]() -> void {\n\n\nWe create a callback to publish the messages periodically\nauto msg = std::make_shared<rosidl_tutorials::msg::AddressBook>();\n\n\nWe create an AddressBook message instance that we will later publish.\n{\nrosidl_tutorials_msgs::msg::Contact contact;\ncontact.first_name = \"John\";\ncontact.last_name = \"Doe\";\ncontact.age = 30;\ncontact.gender = contact.MALE;\ncontact.address = \"unknown\";\nmsg->address_book.push_back(person);\n}\n{\nrosidl_tutorials_msgs::msg::Contact person;\ncontact.first_name = \"Jane\";\ncontact.last_name = \"Doe\";\ncontact.age = 20;\ncontact.gender = contact.FEMALE;\ncontact.address = \"unknown\";\nmsg->address_book.push_back(contact);\n}\n\n\nWe create and populate Contact messages and add them to our address_book message.\nstd::cout << \"Publishing address book:\" << std::endl;\nfor (auto contact : msg->address_book) {\n  std::cout << \"First:\" << contact.first_name << \"  Last:\" << contact.last_name <<\n    std::endl;\n}\n\naddress_book_publisher_->publish(msg);\n\n\nFinally send the message periodically.\ntimer_ = this->create_wall_timer(1s, publish_msg);\n\n\nCreate a 1second timer to call our publish_msg function every second\nNow let’s build it!\nWe need to create a new target for this node in the CMakeLists.txt:\nadd_executable(publish_address_book\n  src/publish_address_book.cpp\n)\n\nament_target_dependencies(publish_address_book\n  \"rclcpp\"\n)\n\n\nIn order to use the messages generated in the same package we need to use the following cmake code:\nget_default_rmw_implementation(rmw_implementation)\nfind_package(\"${rmw_implementation}\" REQUIRED)\nget_rmw_typesupport(typesupport_impls \"${rmw_implementation}\" LANGUAGE \"cpp\")\n\nforeach(typesupport_impl ${typesupport_impls})\n  rosidl_target_interfaces(publish_address_book\n    ${PROJECT_NAME} ${typesupport_impl}\n  )\nendforeach()\n\n\nThis finds the relevant generated C++ code from msg/srv and allows your target to link against them.\nYou may have noticed that this step was not necessary when the interfaces being used were from a package that was built beforehand.\nThis CMake code is only required when you are trying to use interfaces in the same package as that in which they are built.\n\n\n\n\n"},{"id":46,"url":"/doc/ros2/Tutorials/Introspection-with-command-line-tools/","title":"Introspection with command line tools","content":"\nIntrospection with command line tools¶\n\nTable of Contents\n\nUsage\nExample\nBehind the scenes\nImplementation\n\n\nROS 2 includes a suite of command-line tools for introspecting a ROS 2 system.\n\nUsage¶\nThe main entry point for the tools is the command ros2, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more.\nTo see all available sub-commands run:\nros2 --help\n\n\nExamples of sub-commands that are available include:\n\ndaemon: Introspect/configure the ROS 2 daemon\nlaunch: Run a launch file\nlifecycle: Introspect/manage nodes with managed lifecycles\nmsg: Introspect msg types\nnode: Introspect ROS nodes\nparam: Introspect/configure parameters on a node\npkg: Introspect ROS packages\nrun: Run ROS nodes\nsecurity: Configure security settings\nservice: Introspect/call ROS services\nsrv: Introspect srv types\ntopic: Introspect/publish ROS topics\n\n\n\nExample¶\nTo produce the typical talker-listener example using command-line tools, the topic sub-command can be used to publish and echo messages on a topic.\nPublish messages in one terminal with:\n$ ros2 topic pub /chatter std_msgs/String \"data: Hello world\"\npublisher: beginning loop\npublishing std_msgs.msg.String(data='Hello world')\n\npublishing std_msgs.msg.String(data='Hello world')\n\n\nEcho messages received in another terminal with:\n$ ros2 topic echo /chatter\ndata: Hello world\n\ndata: Hello world\n\n\n\n\nBehind the scenes¶\nROS 2 uses a distributed discovery process for nodes to connect to each other.\nAs this process purposefully does not use a centralized discovery mechanism (like the ROS Master in ROS 1), it can take time for ROS nodes to discover all other participants in the ROS graph.\nBecause of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names.\nThe daemon is automatically started when the relevant command-line tools are used for the first time.\nYou can run ros2 daemon --help for more options for interacting with the daemon.\n\n\nImplementation¶\nThe source code for the ros2 command is available at https://github.com/ros2/ros2cli\nThe ros2 tool has been implemented as a framework that can be extended via plugins.\nFor example, the sros2 package provides a security sub-command that is automatically detected by the ros2 tool if the sros2 package is installed.\n\n\n"},{"id":47,"url":"/doc/ros2/Tutorials/Launch-system/","title":"Launching/monitoring multiple nodes with Launch","content":"\nLaunching/monitoring multiple nodes with Launch¶\n\nROS 2 launch system¶\nThe launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described.\nThe configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS specific conventions which make it easy to reuse components throughout the system by giving them each different configurations.\nIt is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes.\nThe ROS 2 Bouncy release includes a framework in which launch files, written in Python, can start and stop different nodes as well as trigger and act on various events.\nThe package providing this framework is launch_ros, which uses the non-ROS-specific launch framework underneath.\nThe design document (in review) details the goal of the design of ROS 2’s launch system (not all functionality is currently available).\n\n\nExample of ROS 2 launch concepts¶\nThe launch file in this example launches two nodes, one of which is a node with a managed lifecycle (a “lifecycle node”).\nLifecycle nodes launched through launch_ros automatically emit events when they transition between states.\nThe events can then be acted on through the launch framework, e.g. by emitting other events (such as requesting another state transition, which lifecycle nodes launched through launch_ros automatically have event handlers for) or triggering other actions (e.g. starting another node).\nIn the aforementioned example, various transition requests are requested of the talker lifecycle node, and  its transition events are reacted to by, for example, launching a listener node when the lifecycle talker reaches the appropriate state.\n\n\nUsage¶\nWhile launch files can be written as standalone scripts, the typical usage in ROS is to have launch files invoked by ROS 2 tools.\nFor example, this launch file has been designed such that it can be invoked by ros2 launch:\nros2 launch demo_nodes_cpp add_two_ints.launch.py\n\n\n\n\nDocumentation¶\nThe launch documentation provides more details on concepts that are also used in launch_ros.\nAdditional documentation/examples of capabilities are forthcoming.\nSee the source code in the meantime.\n\n\n"}]