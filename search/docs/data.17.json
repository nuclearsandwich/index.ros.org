[{"id":68,"url":"/doc/ros2/Contributing/ROS-2-On-boarding-Guide/","title":"ROS 2 On-boarding Guide","content":"\nROS 2 On-boarding Guide¶\nThe purpose of this guide is supplement the on-boarding of new developers when they join the ROS 2 team.\nIt is mostly used by the ROS 2 team, but it might be useful for others as well.\n\nRequest access to the GitHub organizations¶\nOur code is federated across a few GitHub organizations, you’ll want access to them so you can make pull requests with branches rather than forks:\n\nhttps://github.com/ros2\nhttps://github.com/ament\nhttps://github.com/osrf (optional, as-needed)\n\n\n\nRequest access to the buildfarm¶\nThe build farm is hosted at: ci.ros2.org\nTo request access send an email to ros@osrfoundation.org.\n\nHow to give access?¶\nYour GitHub username must be added with the same permissions as existing users to Jenkins (http://ci.ros2.org/configureSecurity/).\nThis can be done by any existing user.\n\n\nHow to access the machines running the ci.ros2.org?¶\nOnly do this if you’re working at OSRF or if you’re asked to log into the machines.\nTo be able to ssh into the node hosted on AWS, you need give request access from Tully Foote (tfoote@osrfoundation.org).\n\n\n\nRequest access to the Google drive ROS2 folder¶\nOnly do this if you’re working at OSRF or need access to a particular document.\nTo request access send an email to ros@osrfoundation.org (anybody on the mailing list can share it).\n\n\nChoose a DDS domain ID¶\nROS2 uses DDS as the underlying transport and DDS supports a physical segmentation of the network based on the “domain ID” (it is used to calculate the multicast port.\nWe use a unique value for this on each machine to keep our ROS2 nodes from interfering from each other.\nWe expose this setting via the ROS_DOMAIN_ID environment variable and use a document to ensure we don’t accidentally choose the same one as someone else.\nThis is, however, only important for people who will be working on the OSRF network, but it isn’t a bad idea to set up at any organization with multiple ROS 2 users on the same network.\n\nGet a Personal ROS_DOMAIN_ID¶\nGo to the ROS 2 Assigned Domain ID’s Spreadsheet and reserve an ID, or email ros@osrfoundation.org and ask for one to be allocated to you.\nNumbers under 128 are preferred.\nTo ensure it is always set, add this line to your ~/.bashrc or equivalent:\nexport ROS_DOMAIN_ID=<your_domain_id>\n\n\n\n\n\nWatching ROS 2 Repositories¶\nWe try to spread our responsibilities out across the team and so we ask everyone to watch the main repositories for ROS 2.\n\nWhat am I currently watching?\n\nhttps://github.com/watching\n\n\nHow do I watch a repository?\n\nhttps://help.github.com/articles/watching-repositories/\n\n\nWhich repositories should I watch?\n\nAll the repositories listed in the ros2.repos file, included the commented out ones,\nAlso all of these extra repositories from the ROS 2 organization:\n\nhttps://github.com/ros2/ci\nhttps://github.com/ros2/design\nhttps://github.com/ros2/ros_astra_camera\nhttps://github.com/ros2/ros_core_documentation\nhttps://github.com/ros2/ros2\nhttps://github.com/ros2/sros2\nhttps://github.com/ros2/turtlebot2_demo\nhttps://github.com/ros2/joystick_drivers\n\n\n\n\n\n\n\nDeveloper Workflow¶\nWe track all open tickets and current PRs using waffle.io: https://waffle.io/ros2/ros2\nHigher level tasks are tracked on the internal (private) Jira: https://osrfoundation.atlassian.net/projects/ROS2\nThe usual workflow is (this list is a work in progress):\n\nDiscuss design (GitHub ticket, and a meeting if needed)\nAssign implementation to a team member\nWrite implementation on a feature branch\n\nPlease check out the developer guide for guidelines and best practices\n\n\nWrite tests\nEnable and run linters\nRun tests locally using colcon test (see colcon tutorial)\nOnce everything builds locally without warnings and all tests are passing, run CI on your feature branch:\n\nGo to ci.ros2.org\nLog in (top right corner)\nClick on the ci_launcher job\nClick “Build with Parameters” (left column)\nIn the first box “CI_BRANCH_TO_TEST” enter your feature branch name\nHit the build button\n\n\nIf built without warnings, errors and test failures, post the links of your jobs on your PR or high level ticket aggregating all your PRs (see example here)\n\nNote that the markdown for these badges is in the console output of the ci_launcher job\n\n\nTo get the PR reviewed, you need to put the label “in review”:\n\nThrough github interface:\n\nClick on “” next to labels\nRemove “in progress” label if applicable\nAdd “in review” label\n\n\nThrough waffle:\n\nDrag your PR to the “in review” column\n\n\n\n\nWhen the PR has been approved:\n\nthe person who submitted the PR merges it using “Squash and Merge” option so that we keep a clean history\n\nIf the commits deserve to keep separated: squash all the nitpick/linters/typo ones together and merge the remaining set\n\nNote: each PR should target a specific feature so Squash and Merge should make sense 99% of the time\n\n\n\n\n\n\nDelete the branch once merged\n\n\n\nWaffle.io How-to¶\nHere are some tips on how to use our Kanban board on waffle.io:\n\nAssigning labels: drag and drop cards to the column with the label you want to assign\nConnecting Issues/PR: Waffle allows to connect cards together using keywords\n\nNote1: The keywords need to be placed in the 1st comment of the GitHub ticket\nNote2: Waffle uses the “simplified” GitHub reference and not the full URL to connect card.\n\nDoes not work:\n\n“connects to https://github.com/ros2/rosidl/issues/216”\n\n\nWorks:\n\nIn the same repo: “connects to #216”\nIn another repo: “connects to ros2/rosidl#216”\n\n\n\n\n\n\n\n\n\nBuild Farm Introduction¶\nThe build farm is located at ci.ros2.org.\nEvery night we run nightly jobs which build and run all the tests in various scenarios on various platforms.\nAdditionally, we test all pull requests against these platforms before merging.\nThis is the current set of target platforms and architectures, though it evolves overtime:\n\nUbuntu 16.04 Xenial\n\namd64\naarch64\n\n\nmacOS 10.12 Sierra\n\namd64\n\n\nWindows 10\n\namd64\n\n\n\nThere several categories of jobs on the buildfarm:\n\nmanual jobs (triggered manually by developers):\n\nci_linux: build + test the code on Ubuntu Xenial\nci_linux-aarch64: build + test the code on Ubuntu Xenial on an ARM 64-bit machine (aarch64)\nci_osx: build + test the code on MacOS 10.12\nci_windows: build + test the code on Windows 10\nci_launcher: trigger all the jobs listed above\n\n\nnightly (run every night):\n\nDebug: build + test the code with CMAKE_BUILD_TYPE=Debug\n\nnightly_linux_debug\nnightly_linux-aarch64_debug\nnightly_osx_debug\nnightly_win_deb\n\n\nRelease: build + test the code with CMAKE_BUILD_TYPE=Release\n\nnightly_linux_release\nnightly_linux-aarch64_release\nnightly_osx_release\nnightly_win_rel\n\n\nRepeated: build then run each test up to 20 times or until failed (aka flakyness hunter)\n\nnightly_linux_repeated\nnightly_linux-aarch64_repeated\nnightly_osx_repeated\nnightly_win_rep\n\n\nCoverage:\n\nnightly_linux_coverage: build + test the code + analyses coverage for c/c++ and python\n\nresults are exported as a cobertura report\n\n\n\n\n\n\npackaging (run every night, against fastrtps; result is bundled into an archive):\n\npackaging_linux\npackaging_osx\nPackaging_windows\n\n\n\n\n\nLearning ROS2 concepts at a high level¶\nAll ROS2 design documents are available at http://design.ros2.org/ and there is some generated documentation at http://docs.ros2.org/.\n\n\n"},{"id":69,"url":"/doc/ros2/Releases/Alpha-Overview/","title":"ROS 2 alpha releases (Aug 2015 - Oct 2016)","content":"\nROS 2 alpha releases (Aug 2015 - Oct 2016)¶\n\nTable of Contents\n\nROS 2 alpha8 release (code name Hook-and-Loop; October 2016)\nROS 2 alpha7 release (code name Glue Gun; July 2016)\nROS 2 alpha6 release (code name Fastener; June 2016)\nROS 2 alpha5 release (code name Epoxy; April 2016)\nROS 2 alpha4 release (code name Duct tape; February 2016)\nROS 2 alpha3 release (code name Cement; December 2015)\nROS 2 alpha2 release (code name Baling wire; October 2015)\nROS 2 alpha1 release (code name Anchor; August 2015)\n\n\nThis is a merged version of the previously separated pages for the 8 alpha releases of ROS 2.\nWe hope that you try them out and provide feedback.\n\nROS 2 alpha8 release (code name Hook-and-Loop; October 2016)¶\n\nTable of Contents\n\nChanges to supported DDS vendors\nScope\n\n\n\nChanges to supported DDS vendors¶\nROS 2 supports multiple middleware implementations (see this page for more details).\nUntil Alpha 8, ROS 2 was supporting ROS middleware implementations for eProsima’s Fast RTPS, RTI’s Connext and PrismTech’s OpenSplice.\nTo streamline our efforts, as of Alpha 8, Fast RTPS and Connext (static) will be supported, with Fast RTPS (now Apache 2.0-licensed) shipped as the default.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from complete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.\nRather, you should expect to try out some demos, explore the code, and perhaps write your own demos.\nThe improvements included in this release are:\n\nSeveral improvements to Fast RTPS and its rmw implementation\n\nSupport for large (image) messages in Fast RTPS\nwait_for_service functionality in Fast RTPS\n\n\nSupport for all ROS 2 message types in Python and C\nAdded support for Quality of Service (QoS) settings in Python\nFixed various bugs with the previous alpha release\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha7 release (code name Glue Gun; July 2016)¶\n\nTable of Contents\n\nNew version of Ubuntu required\nScope\n\n\n\nNew version of Ubuntu required¶\nUntil Alpha 6 ROS 2 was targeting Ubuntu Trusty Tahr (14.04). As of this Alpha ROS 2 is targeting Ubuntu Xenial Xerus (16.04) to benefit from newer versions of the compiler, CMake, Python, etc.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from complete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.\nRather, you should expect to try out some demos, explore the code, and perhaps write your own demos.\nThe major features included in this release are:\n\nGraph API functionality: wait_for_service\n\nAdded interfaces in rclcpp and make use of them in examples, demos, and tests\n\n\nImproved support for large messages in both Connext and Fast-RTPS (partial for Fast-RTPS)\nTurtlebot demo using ported code from ROS 1\n\nSee: https://github.com/ros2/turtlebot2_demo\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha6 release (code name Fastener; June 2016)¶\n\nTable of Contents\n\nScope\n\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nGraph API functionality: wait_for_service\n\nAdded graph guard condition to nodes for waiting on graph changes\nAdded rmw_service_server_is_available for verifying if a service is available\n\n\nRefactored rclcpp to use rcl\nImproved support for complex message types in Python\n\nNested messages\nArrays\nStrings\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha5 release (code name Epoxy; April 2016)¶\n\nTable of Contents\n\nScope\n\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nSupport for C data structures in Fast RTPS and Connext Dynamic rmw implementations.\nSupport services in C.\nAdded 32-bit and 64-bit ARM as experimentally supported platforms.\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha4 release (code name Duct tape; February 2016)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design article,\nwe are engaged in the development of a new major version of ROS, called “ROS 2.”\nWhile the underlying concepts (e.g., publish / subscribe messaging) and goals\n(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their rationale, consult the other\nROS 2 design articles.\n\n\nStatus¶\nOn February 17, 2016, we are releasing ROS 2 alpha4,\ncode-named Duct tape.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nImproved type support infrastructure, including support for C\nPreliminary Python client library, only publishers and subscriptions are supported. Beware, the API is subject to change and is far from complete!\nAdded structures for ROS time in C API (still needs C++ API)\n\nNew concept of extensible “time sources” for ROS Time, the default time source will be like ROS 1 (implementation pending)\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha3 release (code name Cement; December 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design article,\nwe are engaged in the development of a new major version of ROS, called “ROS 2.”\nWhile the underlying concepts (e.g., publish / subscribe messaging) and goals\n(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their rationale, consult the other\nROS 2 design articles.\n\n\nStatus¶\nOn December 18, 2015, we are releasing ROS 2 alpha3,\ncode-named Cement.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nUpdated rcl interface.\n\nThis interface will be wrapped in order to create language bindings, e.g. rclpy.\nThis interface has improved documentation and test coverage over existing interfaces we currently have, e.g. rmw and rclcpp.\nSee rcl headers.\n\n\nAdded support in rclcpp for using the TLSF (two-level segregate fit) allocator, a memory allocator design for embedded and real-time systems.\nImproved efficiency of MultiThreadedExecutor and fixed numerous bugs with multi-threaded execution, which is now test on CI.\nAdded ability to cancel an Executor from within a callback called in spin.\nAdded ability for a timer to cancel itself by supporting a Timer callback that accepts a reference to itself as a function parameter.\nAdded checks for disallowing multiple threads to enter Executor::spin.\nImproved reliability of numerous tests that had been sporadically failing.\nAdded support for using FastRTPS (instead of, e.g., OpenSplice or Connext).\nA partial port of tf2 including the core libraries and core command line tools.\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha2 release (code name Baling wire; October 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design\narticle, we are engaged in\nthe development of a new major version of ROS, called “ROS 2.” While the\nunderlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,\nflexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their\nrationale, consult the other ROS 2 design\narticles.\n\n\nStatus¶\nOn November 3, 2015, we are releasing ROS 2 alpha2,\ncode-named Baling wire.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous alpha 1 release.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nSupport for custom allocators in rclcpp, useful for real-time messaging\nFeature parity of Windows with Linux/OSX, including workspace management, services and parameters\nrclcpp API improvements\nFreeRTPS improvements\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha1 release (code name Anchor; August 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design\narticle, we are engaged in\nthe development of a new major version of ROS, called “ROS 2.” While the\nunderlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,\nflexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their\nrationale, consult the other ROS 2 design\narticles.\n\n\nStatus¶\nOn August 31, 2015, we are releasing ROS 2 alpha1,\ncode-named Anchor.\nOur primary goal with this release is to give\nyou the opportunity to understand how ROS 2 works, in particular how it\ndiffers from ROS 1.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nDiscovery, transport, and serialization use DDS\nSupport multiple DDS vendors\nSupport messaging primitives: topics (publish / subscribe), services (request / response), and parameters\nSupport Linux (Ubuntu Trusty), OS X (Yosemite) and Windows (8)\nUse quality-of-service settings to handle lossy networks\nCommunicate inter-process or intra-process with the same API\nWrite real-time safe code that uses the ROS 2 APIs\nRun ROS 2 on “bare-metal” microcontrollers (no operating system)\nBridge communication between ROS 1 and ROS 2\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\n"},{"id":70,"url":"/doc/ros2/Concepts/DDS-and-ROS-middleware-implementations/","title":"ROS 2 and different DDS/RTPS vendors","content":"\nROS 2 and different DDS/RTPS vendors¶\nROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation.\nThis article explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail, but in summary DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different “Quality of Service” options for the transportation.\nDDS is an industry standard which is then implemented by a range of vendors, such as RTI’s implementation Connext or ADLink’s implementation OpenSplice\nRTPS (a.k.a. DDSI-RTPS) is the wire protocol used by DDS to communicate over the network, and there are implementations of that which do not fulfill the full DDS API, but provide sufficient functionality for ROS 2, such as eProsima’s implementation Fast RTPS.\nROS 2 supports multiple DDS/RTPS implementations because it is not necessarily “one size fits all” when it comes to choosing a vendor/implementation.\nThere are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint.\nVendors may provide more than one DDS or RTPS implementation targeted at meeting different needs.\nFor example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time).\nIn order to use a DDS/RTPS implementation with ROS 2, a “ROS Middleware interface” (a.k.a. rmw interface or just rmw) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation’s API and tools.\nIt’s a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project’s needs.\n\nSupported RMW implementations¶\n\n\n\n\n\n\n\n\nProduct name\nLicense\nRMW implementation\nStatus\n\n\n\neProsima Fast RTPS\nApache 2\nrmw_fastrtps_cpp\nFull support. Default RMW. Packaged with binary releases.\n\nRTI Connext\ncommercial, research\nrmw_connext_cpp\nFull support. Support included in binaries, but Connext installed separately.\n\nRTI Connext (dynamic implementation)\ncommercial, research\nrmw_connext_dynamic_cpp\nSupport paused. Full support until alpha 8.*\n\nPrismTech Opensplice\nLGPL (only v6.4), commercial\nrmw_opensplice_cpp\nPartial support. Support included in binaries, but OpenSplice installed separately.\n\nOSRF FreeRTPS\nApache 2\n–\nPartial support. Development paused.\n\n\n\n“Partial support” means that one or more of the features required by the rmw interface is not implemented.\nFor practical information on working with multiple RMW implementations, see the \"Working with multiple RMW implementations\" tutorial.\n\n\n"},{"id":71,"url":"/doc/ros2/Tutorials/Real-Time-Programming/","title":"Real-Time Programming in ROS 2","content":"\nReal-Time Programming in ROS 2¶\n\nTable of Contents\n\nBackground\nInstall and run the demo\n\nRun the tests\nWhat the heck just happened?\nAdjust permissions for memory locking\nOutput overview\nLatency\nSetting permissions for the scheduler\nPlotting results\n\n\n\n\n\nBackground¶\nReal-time computing is a key feature of many robotics systems, particularly safety- and mission-critical applications such as autonomous vehicles, spacecrafts, and industrial manufacturing.\nWe are designing and prototyping ROS 2 with real-time performance constraints in mind, since this is a requirement that was not considered in the early stages of ROS 1 and it is now intractable to refactor ROS 1 to be real-time friendly.\nThis document outlines the requirements of real-time computing and best practices for software engineers. tl;dr:\nTo make a real-time computer system, our real-time loop must update periodically to meet deadlines.\nWe can only tolerate a small margin of error on these deadlines (our maximum allowable jitter).\nTo do this, we must avoid nondeterministic operations in the execution path, things like: pagefault events, dynamic memory allocation/deallocation, and synchronization primitives that block indefinitely.\nA classic example of a controls problem commonly solved by real-time computing is balancing an inverted pendulum.\nIf the controller blocked for an unexpectedly long amount of time, the pendulum would fall down or go unstable.\nBut if the controller reliably updates at a rate faster than the motor controlling the pendulum can operate, the pendulum will successfully adapt react to sensor data to balance the pendulum.\nNow that you know everything about real-time computing, let’s try a demo!\n\n\nInstall and run the demo¶\nThe real-time demo was written with Linux operating systems in mind, since many members of the ROS community doing real-time computing use Xenomai or RT_PREEMPT as their real-time solutions.\nSince many of the operations done in the demo to optimize performance or OS-specific, the demo only builds and runs on Linux systems.\nSo, if you are an OSX or Windows user, don’t try this part!\nAlso this must be built from source using a the static DDS API. Currently the only supported implementation is Connext.\nFirst, follow the instructions to build ROS 2 from source using Connext DDS as the middleware.\n\nRun the tests¶\nBefore you run make sure you have at least 8Gb of RAM free. With the memory locking, swap will not work anymore.\nSource your ROS 2 setup.bash.\nRun the demo binary, and redirect the output. You may want to use sudo in case you get permission error:\npendulum_demo > output.txt\n\n\n\n\nWhat the heck just happened?¶\nFirst, even though you redirected stdout, you will see some output to the console (from stderr):\nmlockall failed: Cannot allocate memory\nCouldn't lock all cached virtual memory.\nPagefaults from reading pages not yet mapped into RAM will be recorded.\n\n\nAfter the initialization stage of the demo program, it will attempt to lock all cached memory into RAM and prevent future dynamic memory allocations using mlockall.\nThis is to prevent pagefaults from loading lots of new memory into RAM.\n(See the realtime design article for more information.)\nThe demo will continue on as usual when this occurs.\nAt the bottom of the output.txt file generated by the demo, you’ll see the number of pagefaults encountered during execution:\nrttest statistics:\n  - Minor pagefaults: 20\n  - Major pagefaults: 0\n\n\nIf we want those pagefaults to go away, we’ll have to…\n\n\nAdjust permissions for memory locking¶\nAdd to /etc/security/limits.conf (as sudo):\n<your username>    -   memlock   <limit in kB>\n\n\nA limit of -1 is unlimited.\nIf you choose this, you may need to accompany it with ulimit -l unlimited after editing the file.\nAfter saving the file, log out and log back in.\nThen rerun the pendulum_demo invocation.\nYou’ll either see zero pagefaults in your output file, or an error saying that a bad_alloc exception was caught.\nIf this happened, you didn’t have enough free memory available to lock the memory allocated for the process into RAM.\nYou’ll need to install more RAM in your computer to see zero pagefaults!\n\n\nOutput overview¶\nTo see more output, we have to run the pendulum_logger node.\nIn one shell with your install/setup.bash sourced, invoke:\npendulum_logger\n\n\nYou should see the output message:\nLogger node initialized.\n\n\nIn another shell with setup.bash sourced, invoke pendulum_demo again.\nAs soon as this executable starts, you should see the other shell constantly printing output:\nCommanded motor angle: 1.570796\nActual motor angle: 1.570796\nMean latency: 210144.000000 ns\nMin latency: 4805 ns\nMax latency: 578137 ns\nMinor pagefaults during execution: 0\nMajor pagefaults during execution: 0\n\n\nThe demo is controlling a very simple inverted pendulum simulation.\nThe pendulum simulation calculates its position in its own thread.\nA ROS node simulates a motor encoder sensor for the pendulum and publishes its position.\nAnother ROS node acts as a simple PID controller and calculates the next command message.\nThe logger node periodically prints out the pendulum’s state and the runtime performance statistics of the demo during its execution phase.\nAfter the pendulum_demo is finished, you’ll have to CTRL-C out of the logger node to exit.\n\n\nLatency¶\nAt the pendulum_demo execution, you’ll see the final statistics collected for the demo:\nrttest statistics:\n  - Minor pagefaults: 0\n  - Major pagefaults: 0\n  Latency (time after deadline was missed):\n    - Min: 3354 ns\n    - Max: 2752187 ns\n    - Mean: 19871.8 ns\n    - Standard deviation: 1.35819e+08\n\nPendulumMotor received 985 messages\nPendulumController received 987 messages\n\n\nThe latency fields show you the minimum, maximum, and average latency of the update loop in nanoseconds.\nHere, latency means the amount of time after the update was expected to occur.\nThe requirements of a real-time system depend on the application, but let’s say in this demo we have a 1KHz (1 millisecond) update loop, and we’re aiming for a maximum allowable latency of 5% of our update period.\nSo, our average latency was really good in this run, but the maximum latency was unacceptable because it actually exceeded our update loop! What happened?\nWe may be suffering from a non-deterministic scheduler.\nIf you’re running a vanilla Linux system and you don’t have the RT_PREEMPT kernel installed, you probably won’t be able to meet the real-time goal we set for ourselves, because the Linux scheduler won’t allow you to arbitrarily pre-empt threads at the user level.\nSee the realtime design article for more information.\nThe demo attempts to set the scheduler and thread priority of the demo to be suitable for real-time performance.\nIf this operation failed, you’ll see an error message: “Couldn’t set scheduling priority and policy: Operation not permitted”.\nYou can get slightly better performance by following the instructions in the next section:\n\n\nSetting permissions for the scheduler¶\nAdd to /etc/security/limits.conf (as sudo):\n<your username>    -   rtprio   98\n\n\nThe range of the rtprio (real-time priority) field is 0-99.\nHowever, do NOT set the limit to 99 because then your processes could interfere with important system processes that run at the top priority (e.g. watchdog).\nThis demo will attempt to run the control loop at priority 98.\n\n\nPlotting results¶\nYou can plot the latency and pagefault statistics that are collected in this demo after the demo runs.\nBecause the code has been instrumented with rttest, there are useful command line tools available to us:\n-i Specify how many iterations to run the real-time loop.\nDefault is 1000.\n-u Specify the update period.\nDefault units are microseconds.\nUse the suffix “s” for seconds, “ms” for milliseconds, “us” for microseconds, and “ns” for nanoseconds.\nDefault update period is 1ms.\n-f Specify the name of the file for writing the collected data.\nRun the demo again with the name a file to save results to:\npendulum_demo -f pendulum_demo_results\n\n\nThen run the rttest_plot script on the resulting file:\nrttest_plot pendulum_demo_results\n\n\nThis script will produce three files:\npendulum_demo_results_plot_latency.svg\npendulum_demo_results_plot_majflts.svg\npendulum_demo_results_plot_minflts.svg\n\n\nYou can view these plots in an image viewer of your choice.\n\n\n\n"}]