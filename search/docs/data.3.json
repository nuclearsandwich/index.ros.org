[{"id":12,"url":"/doc/ros2/Concepts/About-ROS-Interfaces/","title":"About ROS 2 Interfaces","content":"\nAbout ROS 2 Interfaces¶\n\nTable of Contents\n\n1. Background\n2. Message Description Specification\n\n2.1 Fields\n\n2.1.1 Field Types\n2.1.2 Field Names\n2.1.3 Field Default Value\n\n\n2.2 Constants\n\n\n3. Service Description Specification\n\n\n\n1. Background¶\nROS applications typically communicate through interfaces of one of two types: messages and services.\nROS uses a simplified description language to describe these interfaces. This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages.\nIn this document we will describe the supported types and how to create your own msg/srv files.\n\n\n2. Message Description Specification¶\nMessages description are defined in .msg files in the msg/ directory of a ROS package.\n.msg files are composed of two parts: fields and constants.\n\n2.1 Fields¶\nEach field consists of a type and a name, separated by a space, i.e:\nfieldtype1 fieldname1\nfieldtype2 fieldname2\nfieldtype3 fieldname3\n\n\nFor example:\nint32 my_int\nstring my_string\n\n\n\n2.1.1 Field Types¶\nField types can be:\n\na built-in-type\nnames of Message descriptions defined on their own, such as “geometry_msgs/PoseStamped”\n\nBuilt-in-types currently supported:\n\n\n\n\n\n\n\n\nType name\nC++\nPython\nDDS type\n\n\n\nbool\nbool\nbuiltins.bool\nboolean\n\nbyte\nuint8_t\nbuiltins.bytes*\noctet\n\nchar\nchar\nbuiltins.str*\nchar\n\nfloat32\nfloat\nbuiltins.float*\nfloat\n\nfloat64\ndouble\nbuiltins.float*\ndouble\n\nint8\nint8_t\nbuiltins.int*\noctet\n\nuint8\nuint8_t\nbuiltins.int*\noctet\n\nint16\nint16_t\nbuiltins.int*\nshort\n\nuint16\nuint16_t\nbuiltins.int*\nunsigned short\n\nint32\nint32_t\nbuiltins.int*\nlong\n\nuint32\nuint32_t\nbuiltins.int*\nunsigned long\n\nint64\nint64_t\nbuiltins.int*\nlong long\n\nuint64\nuint64_t\nbuiltins.int*\nunsigned long long\n\nstring\nstd::string\nbuiltins.str\nstring\n\n\n\nEvery built-in-type can be used to define arrays:\n\n\n\n\n\n\n\n\nType name\nC++\nPython\nDDS type\n\n\n\nstatic array\nstd::array<T, N>\nbuiltins.list*\nT[N]\n\nunbounded dynamic array\nstd::vector\nbuiltins.list\nsequence\n\nbounded dynamic array\ncustom_class<T, N>\nbuiltins.list*\nsequence<T, N>\n\nbounded string\nstd::string\nbuiltins.str*\nstring\n\n\n\nAll types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software\nExample of message definition using arrays and bounded types:\nint32[] unbounded_integer_array\nint32[5] five_integers_array\nint32[<=5] up_to_five_integers_array\n\nstring string_of_unbounded_size\nstring<=10 up_to_ten_characters_string\n\nstring[<=5] up_to_five_unbounded_strings\nstring<=10[] unbounded_array_of_string_up_to_ten_characters each\nstring<=10[<=5] up_to_five_strings_up_to_ten_characters_each\n\n\n\n\n2.1.2 Field Names¶\nField names must be lowercase alphanumeric characters with underscores for separating words. They must start with an alphabetic character, they must not end with an underscore and never have two consecutive underscores.\n\n\n2.1.3 Field Default Value¶\nDefault values can be set to any field in the message type.\nCurrently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above, that applies to all nested messages)\nDefining a default value is done by adding a third element to the field definition line, i.e:\nfieldtype fieldname fielddefaultvalue\n\n\nFor example:\nuint8 x 42\nint16 y -2000\nstring full_name \"John Doe\"\nint32[] samples [-200, -100, 0, 100, 200]\n\n\nNote:\n\nstring values must be defined in single ' or double quotes \"\ncurrently string values are not escaped\n\n\n\n\n2.2 Constants¶\nEach constant definition is like a field description with a default value, except that this value can never be changed programatically. This value assignment is indicated by use of an equal ‘=’ sign, e.g.\nconstanttype CONSTANTNAME=constantvalue\n\n\nFor example:\nint32 X=123\nint32 Y=-123\nstring FOO=\"foo\"\nstring EXAMPLE='bar'\n\n\n\nNote\nConstants names have to be UPPERCASE\n\n\n\n\n3. Service Description Specification¶\nServices description are defined in .srv files in the srv/ directory of a ROS package.\nA service description file consists of a request and a response msg type, separated by ‘—’. Any two .msg files concatenated together with a ‘—’ are a legal service description.\nHere is a very simple example of a service that takes in a string and returns a string:\nstring str\n---\nstring str\n\n\nWe can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):\n#request constants\nint8 FOO=1\nint8 BAR=2\n#request fields\nint8 foobar\nanother_pkg/AnotherMessage msg\n---\n#response constants\nuint32 SECRET=123456\n#response fields\nanother_pkg/YetAnotherMessage val\nCustomMessageDefinedInThisPackage value\nuint32 an_integer\n\n\nYou cannot embed another service inside of a service.\n\n\n"},{"id":13,"url":"/doc/ros2/Concepts/ROS-2-Client-Libraries/","title":"About ROS2 client libraries","content":"\nAbout ROS2 client libraries¶\n\nTable of Contents\n\nOverview\nSupported client libraries\nCommon functionality: the RCL\nLanguage-specific functionality\nDemo\nComparison to ROS 1\nSummary\n\n\n\nOverview¶\nClient libraries are the APIs that allow users to implement their ROS code.\nThey are what users use to get access to ROS concepts such as nodes, topics, services, etc.\nClient libraries come in a variety of programming languages so that users may write ROS code in the language that is best-suited for their application.\nFor example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++.\nNodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS interface files in the respective language.\nIn addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS “ROS”.\nFor example, here is a list of functionality that can typically be accessed through a client library:\n\nNames and namespaces\nTime (real or simulated)\nParameters\nConsole logging\nThreading model\nIntra-process communication\n\n\n\nSupported client libraries¶\nThe C++ client library (rclcpp) and the Python client library (rclpy) are both client libraries which utilize common functionality in the RCL.\nWhile the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community have created additional client libraries:\n\nJVM and Android\nObjective C and iOS\nC#\nSwift\nNode.js\nAda\n\n\n\nCommon functionality: the RCL¶\nMost of the functionality found in a client library is not specific to the programming language of the client library.\nFor example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages.\nBecause of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific.\nAs a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces.\nThis keeps client libraries thinner and easier to develop.\nFor this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap.\nIn addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent.\nIf any changes are made to the logic/behavior of the functionality in the core RCL – namespaces, for example – all client libraries that use the RCL will have these changes reflected.\nFurthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes.\nThe API documentation for the RCL can be found here.\n\n\nLanguage-specific functionality¶\nClient library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library.\nFor example, threading models used by “spin” functions will have implementations that are specific to the language of the client library.\n\n\nDemo¶\nFor a walkthrough of the message exchange between a publisher using rclpy and a subscriber using rclcpp, we encourage you to watch this ROSCon talk starting at 17:25 (here are the slides).\n\n\nComparison to ROS 1¶\nIn ROS 1, all client libraries are developed “from the ground up”.\nThis allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code.\nHowever, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS).\n\n\nSummary¶\nBy utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior.\n\n\n"},{"id":14,"url":"/doc/ros2/Releases/Beta1-Overview/","title":"Beta 1 (codename ‘Asphalt’; December 2016)","content":"\nBeta 1 (codename ‘Asphalt’; December 2016)¶\n\nTable of Contents\n\nSupported Platforms\nFeatures\n\nImprovements since Alpha 8 release\nSelected features from previous Alpha releases\nKnown issues\n\n\n\n\n\nSupported Platforms¶\nWe support ROS 2 Beta 1 on three platforms: Ubuntu 16.04 (Xenial), Mac OS X 10.11 (El Capitan), and Windows 8.1 and 10. We provide both binary packages and instructions for how to compile from source for all 3 platforms.\n\n\nFeatures¶\n\nImprovements since Alpha 8 release¶\n\nSupport for node composition at compile, link, or runtime.\nA standard lifecycle for managed nodes.\nImproved support for Quality of Service tuning and tests.\nNew and updated design documents\nMore tutorials and examples\nBridging services to / from ROS1 (in addition to topics)\n\n\n\nSelected features from previous Alpha releases¶\nFor the complete list, see earlier release notes.\n\nC++ and Python implementations of ROS 2 client libraries including APIs for:\n\nPublishing and subscribing to ROS topics\nRequesting and replying ROS services (synchronous (C++ only) and asynchronous)\nGetting and setting ROS parameters (C++ only, synchronous and asynchronous)\nTimer callbacks\nSupport for interoperability between multiple DDS/RTPS implementations\neProsima FastRTPS is our default implementation, and is included in the binary packages\nRTI Connext is supported: build from source to try it out\nWe initially supported PrismTech OpenSplice but eventually decided to drop it\n\n\nA graph API for network events\nDistributed discovery\nRealtime safe code paths for publish and subscribe with compatible DDS implementation (only Connext at the moment)\n\nSupport for custom allocators\n\n\nROS 1 <-> ROS 2 dynamic bridge node\nExecutor threading model in C++\nExtended .msg format with new features:\n\nBounded arrays\nDefault values\n\n\n\n\n\nKnown issues¶\n\nWe’re tracking issues in various repositories, but the main entry point is the ros2/ros2 issue tracker\nWe’d like to highlight a known issue that we are working with eProsima to fix that results in significantly degrated performance for large messages under FastRTPS.\nThis will be observed when running some of the demos with larger image resolutions.\n\n\n\n\n"},{"id":15,"url":"/doc/ros2/Releases/Beta2-Overview/","title":"Beta 2 (codename ‘r2b2’; July 2017)","content":"\nBeta 2 (codename ‘r2b2’; July 2017)¶\n\nTable of Contents\n\nSupported Platforms\nFeatures\n\nImprovements since Beta 1 release\nNew demo application\nSelected features from previous Alpha/Beta releases\nKnown issues\n\n\n\n\n\nSupported Platforms¶\nWe support ROS 2 Beta 2 on three platforms: Ubuntu 16.04 (Xenial), Mac OS X 10.12 (Sierra), and Windows 10.\nWe provide both binary packages and instructions for how to compile from source for all 3 platforms (see install instructions as well as documentation).\n\n\nFeatures¶\n\nImprovements since Beta 1 release¶\n\nDDS_Security support (aka SROS2, see sros2)\nDebian packages for Ubuntu Xenial (see Debian install instructions).\nTypesupport has been redesigned so that you only build a single executable and can choose one of the available RMW implementations by setting an environment variable (see documentation).\nNamespace support for nodes and topics (see design article, see known issues below).\nA set of command-line tools using the extensible ros2 command (see tutorial).\nA set of macros for logging messages in C / C++ (see API docs of rcutils).\n\n\n\nNew demo application¶\n\nTurtlebot 2 demos using the following repositories that have been (partially) converted to ROS 2 (Linux only):\n\nros_astra_camera\ndepthimage_to_laserscan\npcl_conversions\ncartographer\ncartographer_ros\nceres-solver\nnavigation\nteleop_twist_keyboard\njoystick_drivers\nteleop_twist_joy\n\n\nDummy_robot demo:\n\nrobot_model\nrobot_state_publisher\n\n\n\n\n\nSelected features from previous Alpha/Beta releases¶\nFor the complete list, see earlier release notes.\n\nC++ and Python implementations of ROS 2 client libraries including APIs for:\n\nPublishing and subscribing to ROS topics\nRequesting and replying ROS services (synchronous (C++ only) and asynchronous)\nGetting and setting ROS parameters (C++ only, synchronous and asynchronous)\nTimer callbacks\n\n\nSupport for interoperability between multiple DDS/RTPS implementations\n\neProsima FastRTPS is our default implementation, and is included in the binary packages\nRTI Connext is supported: build from source to try it out\nWe initially supported PrismTech OpenSplice but support for it is currently on hold\n\n\nA graph API for network events\nDistributed discovery\nRealtime safe code paths for publish and subscribe with compatible DDS implementation (only Connext at the moment)\n\nSupport for custom allocators\n\n\nROS 1 <-> ROS 2 dynamic bridge node\nExecutor threading model (C++ only)\nComponent model to compose nodes at compile / link / runtime\nManaged component using a standard lifecycle\nExtended .msg format with new features:\n\nBounded arrays\nDefault values\n\n\n\n\n\nKnown issues¶\n\nWe’re tracking issues in various repositories, but the main entry point is the ros2/ros2 issue tracker\nWe’d like to highlight a known issue that we are looking into which doesn’t allow two topics with the same base name but different namespaces to have a different type when using rmw_connext_cpp.\nServices with long responses are not working with Fast-RTPS. The fix, while not being part of beta2, is available upstream so you can work around this issue by building from source using Fast-RTPS master branch.\n\n\n\n\n"}]