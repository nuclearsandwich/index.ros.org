[{"id":32,"url":"/doc/ros2/Tutorials/RQt-Source-Install/","title":"Building RQt from Source","content":"\nBuilding RQt from Source¶\nWe’ve provided our development setup here to aid future users in easily extending RQt by creating their own plugins. We encourage you to contribute those plugins back to the ros-visualization Github repository!\n\nSystem Requirements¶\nThese instructions are written for the target platforms for Crystal Clemmys (see REP).\n\nUbuntu Bionic Beaver 18.04 64-bit\nMac OSX Sierra 10.12.x\nWindows 10 with Visual Studio 2017\n\n\nOther Requirements¶\n\nIn ROS 2 Crystal the minimum Qt version is Qt5\n\n\n\n\nBuilding From Source¶\nIn order to build RQt from source, first create a ROS2 workspace at ~/ros2_ws/.\nThis is step is already covered in building ROS 2 from source instructions, so we skip it here.\n\nDownload RQt Repositories¶\ncd ~/ros2_ws\nwget https://raw.githubusercontent.com/PickNikRobotics/rqt2_setup/master/rqt2.repos\nvcs import src --force < rqt2.repos\n\n\nAs an alternative to the hosted .repos file you can use rosinstall_generator to generate a custom one:\nrosinstall_generator --rosdistro crystal --upstream-development --repos python_qt_binding qt_gui_core rqt <more-repos-with-rqt-plugins> > rqt2.repos\n\n\n\n\nInstall Dependencies¶\n\n\nFor non-Linux platforms, see the macOS RQt source install page or the Windows 10 RQt source install page before continuing here.\nrosdep install --from-paths src --ignore-src --rosdistro bouncy -y --skip-keys \"console_bridge fastcdr fastrtps libopensplice67 rti-connext-dds-5.3.1 urdfdom_headers\"\n\n\n\n\nBuild The Workspace¶\nGenerally building a workspace is as simple as:\ncolcon build\n\n\nFor Windows, it is recommended to use the --merge-install option.\ncolcon build --merge-install\n\n\nAdvanced Colcon usages:\n\nShow verbose output on the console:\ncolcon build –event-handlers console_direct+\n\n\n\nOnly build one package and its dependencies:\ncolcon build –packages-up-to rqt_shell\n\n\n\n\n\n\nSource your environment¶\nLinux or macOS\n. install/local_setup.bash\n\n\nWindows\ncall install/local_setup.bat\n\n\n\n\n\nUsing RQt¶\nSee Overview of RQt.\n\n\n"},{"id":33,"url":"/doc/ros2/Tutorials/Quality-of-Service/","title":"Use quality-of-service settings to handle lossy networks","content":"\nUse quality-of-service settings to handle lossy networks¶\n\nTable of Contents\n\nBackground\nBuild/install the demo\nFrom pre-compiled binaries\nFrom source\n\n\nRun the demo\nCommand line options\nAdd network traffic\n\n\n\n\n\nBackground¶\nPlease read the documentationg page about QoS settings for background information on available support in ROS 2.\nIn this demo, we will spawn a node that publishes a camera image and another that subscribes to the image and shows it on the screen.\nWe will then simulate a lossy network connection between them and show how different quality of service settings handle the bad link.\n\n\nBuild/install the demo¶\n\nFrom pre-compiled binaries¶\nSimply download the binary packages for your OS from the installation page.\n\n\nFrom source¶\nOpenCV is a prerequisite for the QoS demo.\nSee the OpenCV documentation for installation instructions.\nFollow the instructions on the installation page for your particular platform.\n\n\n\nRun the demo¶\nBefore running the demo, make sure you have a working webcam connected to your computer.\nOnce you’ve installed ROS 2, if you’re on Linux, source your setup.bash file:\n. <path to ROS 2 install space>/setup.bash\n\n\nor if you’re on Windows cmd:\ncall <path to ROS 2 install space>/local_setup.bat\n\n\nThen run:\nros2 run image_tools showimage\n\n\nNothing will happen yet.\nshowimage is a subscriber node that is waiting for a publisher on the image topic.\nNote: you have to close the showimage process with Ctrl-C later.\nYou can’t just close the window.\nIn a separate terminal, source the install file and run the publisher node:\nros2 run image_tools cam2image\n\n\nThis will publish an image from your webcam. In case you don’t have a camera attached to your computer, there is a commandline option which publishes predefined images.\nros2 run image_tools cam2image -b\n\n\nIn this window, you’ll see terminal output:\nPublishing image #1\nPublishing image #2\nPublishing image #3\n...\n\n\nA window will pop up with the title “view” showing your camera feed.\nIn the first window, you’ll see output from the subscriber:\nReceived image #1\nReceived image #2\nReceived image #3\n...\n\n\nNote for OS X users: If you these examples do not work or you receive an error like ddsi_conn_write failed -1 then you’ll need to increase your system wide UDP packet size:\n$ sudo sysctl -w net.inet.udp.recvspace=209715\n$ sudo sysctl -w net.inet.udp.maxdgram=65500\n\n\nThese changes will not persist a reboot. If you want the changes to persist, add these lines to /etc/sysctl.conf (create the file if it doesn’t exist already):\nnet.inet.udp.recvspace=209715\nnet.inet.udp.maxdgram=65500\n\n\n\nCommand line options¶\nIn one of your terminals, add a -h flag to the original command:\nros2 run image_tools showimage -- -h\n\n\nYou’ll see a list of the possible options you can pass to the demo.\n-h: The help message.\n-r: Reliability.\nThere are two options for this policy: reliable or best effort.\nReliable means that values may be reset and the underlying DDS publisher might block, in order for messages to get delivered in order.\nBest effort means that messages will get sent as is, and they may get dropped or lost without effecting the behavior of the publisher.\n-k: History policy (the “k” stands for “keep”).\nDetermines how DDS buffers messages in the time between the user code that called publish and the time when the message actually gets sent.\nThere are two options for history: KEEP_ALL and KEEP_LAST.\nKEEP_ALL will buffer all messages before they get sent.\nKEEP_LAST limits the number of buffered messages to a depth specified by the user.\n-d: Queue depth.\nOnly used if the history policy is set to KEEP_LAST.\nThe queue depth determines the maximum number of not yet received messages that get buffered on the sender’s side before messages start getting dropped.\n-t TOPIC: Topic to use.\nThe topic to use (default: image)\nIf you run cam2image -h, you’ll see the same set of command line options and some additional ones:\n-s: Toggle displaying the input camera stream.\nIf you run cam2image -s by itself, you’ll see a camera window.\nIf you also run showimage, you’ll see two camera windows.\n-x and -y: Set the size of the camera feed (x sets the width, y sets the height).\n-b: Produce images of burgers rather than connecting to a camera\n-f: Publish frequency in Hz. (default: 30)\nThe default quality of service settings are tuned for maximum reliability: the reliability policy is reliable, and the history policy is “keep all”.\nIt’s worth noting that both ends must have the same reliability settings for this to work.\nIf the consumer requires the publisher to be reliable, DDS will not match them and there won’t be any exchange between them.\nWe won’t see much of a difference if we change the quality of service settings, since the publisher and subscriber are passing messages over inter-process communication, and messages are unlikely to get dropped if they are travelling within the same machine.\n\n\nAdd network traffic¶\n\nWarning\nThis section of the demo won’t work on RTI’s Connext DDS.\nWhen running multiple nodes in the same host, the RTI Connext implementation uses shared memory along with the loopback interface.\nDegrading the loopback interface throughput won’t affect shared memory, thus traffic between the two nodes won’t be affected.\nSee RMW implementation code and RTI Connext Documentation  for further reference.\n\n\nNote\nThis next section is Linux-specific.\n\nHowever, for OS X and Windows you can achieve a similar effect with the utilities “Network Link Conditioner” (part of the xcode tool suite) and “Clumsy” (http://jagt.github.io/clumsy/index.html), respectively, but they will not be covered in this tutorial.\nWe are going to use the Linux network traffic control utility, tc (http://linux.die.net/man/8/tc).\nsudo tc qdisc add dev lo root netem loss 5%\n\n\nThis magical incantation will simulate 5% packet loss over the local loopback device.\nIf you use a higher resolution of the images (e.g. -x 640 -y 480) you might want to try a lower packet loss rate (e.g. 1%).\nNext we start the cam2image and showimage, and we’ll soon notice that both programs seem to have slowed down the rate at which images are transmitted.\nThis is caused by the behavior of the default QoS settings.\nEnforcing reliability on a lossy channel means that the publisher (in this case, cam2image) will resend the network packets until it receives acknowledgement from the consumer (i.e. showimage).\nLet’s now try running both programs, but with more suitable settings.\nFirst of all, we’ll use the -r 0 option to enable best effort communication.\nThe publisher will now just attempt to deliver the network packets, and don’t expect acknowledgement from the consumer.\nWe see now that some of the frame on the showimage side were dropped, the frame numbers in the shell running showimage won’t be consecutive anymore:\n\nWhen you’re done, remember to delete the queueing discipline:\nsudo tc qdisc delete dev lo root netem loss 5%\n\n\n\n\n\n"},{"id":34,"url":"/doc/ros2/Contributing/Migration-Guide/","title":"Migration guide from ROS 1","content":"\nMigration guide from ROS 1¶\nThis article describes the high-level steps to migrate a ROS 1 package to ROS 2.\nIt does not aim to be a step-by-step migration instruction and is not considered the final “solution”.\nFuture versions will aim to make migration smoother and less effort up to the point that maintaining a single package from the same branch for ROS 1 as well as ROS 2.\n\nPrerequisites¶\nBefore being able to migrate a ROS 1 package to ROS 2 all of its dependencies must be available in ROS 2.\n\n\nMigration steps¶\n\n\nPackage manifests\nMessage and service definitions\nBuild system\nUpdate source code\n\n\n\nPackage manifests¶\nROS 2 only support the format 2 of the package specification which is defined in REP 140.\nTherefore the package.xml file must be updated to format 2 if it uses format 1.\nSince ROS 1 support both formats (1 as well as 2) it is safe to perform that conversion in the ROS 1 package.\nSome packages might have different names in ROS 2 so the dependencies might need to be updated accordingly.\n\n\nMessage and service definitions¶\nMessage files must end in .msg and must be located in the subfolder msg.\nService files must end in .srv and must be located in the subfolder srv.\nThese files might need to be updated to comply with the ROS Interface definition.\nSome primitive types have been removed and the types duration and time which were builtin types in ROS 1 have been replaced with normal message definitions and must be used from the builtin_interfaces package.\nAlso some naming conventions are stricter then in ROS 1.\nIn your package.xml:\n\nAdd <buildtool_depend>rosidl_default_generators</buildtool_depend>.\nAdd <exec_depend>rosidl_default_runtime</exec_depend>.\nFor each dependent message package, add <depend>message_package</depend>.\n\nIn your CMakeLists.txt:\n\nStart by enabling C++11\n\nif(NOT WIN32)\n  add_definitions(-std=c++11)\nendif()\n\n\n\nAdd find_package(rosidl_default_generators REQUIRED)\nFor each dependent message package, add find_package(message_package REQUIRED) and replace the cmake function call to generate_messages with rosidl_generate_interfaces.\n\nThis will replace add_message_files and add_service_files listing of all the message and service files, which can be removed.\n\n\nBuild system¶\nThe build system in ROS 2 is called ament.\n\nBuild tool¶\nInstead of using catkin_make, catkin_make_isolated or catkin build ROS 2 uses the command line tool colcon to build and install a set of packages.\n\n\nPure Python package¶\nIf the ROS 1 package uses CMake only to invoke the setup.py file and does not contain anything beside Python code (e.g. also no messages, services, etc.) it should be converted into a pure Python package in ROS 2:\n\nUpdate or add the build type in the package.xml file:\n<export>\n  <build_type>ament_python</build_type>\n</export>\n\n\n\nRemove the CMakeLists.txt file\n\nUpdate the setup.py file to be a standard Python setup script\n\n\nROS 2 supports Python 3 only.\nWhile each package can choose to also support Python 2 it must invoke executables with Python 3 if it uses any API provided by other ROS 2 packages.\n\n\nUpdate the CMakeLists.txt to use ament_cmake¶\nApply the following changes to use ament_cmake instead of catkin:\n\nSet the build type in the package.xml file export section:\n<export>\n  <build_type>ament_cmake</build_type>\n</export>\n\n\n\nReplace the find_package invocation with catkin and the COMPONENTS with:\nfind_package(ament_cmake REQUIRED)\nfind_package(component1 REQUIRED)\n# ...\nfind_package(componentN REQUIRED)\n\n\n\nMove and update the catkin_package invocation with:\n\nInvoke ament_package instead but after all targets have been registered.\nThe only valid argument for ament_package is CONFIG_EXTRAS.\nAll other arguments are covered by separate functions which all need to be invoked before ament_package:\nInstead of passing CATKIN_DEPENDS ... call ament_export_dependencies(...) before.\nInstead of passing INCLUDE_DIRS ... call ament_export_include_directories(...) before.\nInstead of passing LIBRARIES ... call ament_export_libraries(...) before.\n\n\nTODO document ament_export_interfaces?\n\n\nReplace the invocation of add_message_files, add_service_files and generate_messages with rosidl_generate_interfaces.\n\nThe first argument is the target_name.\nIf you’re building just one library it’s ${PROJECT_NAME}\n\nFollowed by the list of message filenames, relative to the package root.\n\nIf you will be using the list of filenames multiple times, it is recommended to compose a list of message files and pass the list to the function for clarity.\n\n\nThe final multi-value-keyword argument fpr generate_messages is DEPENDENCIES which requires the list of dependent message packages.\nrosidl_generate_interfaces(${PROJECT_NAME}\n  ${msg_files}\n  DEPENDENCIES std_msgs\n)\n\n\n\n\n\nRemove any occurrences of the devel space.\nRelated CMake variables like CATKIN_DEVEL_PREFIX do not exist anymore.\n\nThe CATKIN_DEPENDS and DEPENDS arguments are passed to the new function ament_export_dependencies.\n\n\nReplace the invocation of add_message_files, add_service_files and generate_messages with rosidl_generate_interfaces.\n\nRemove any occurrences of the devel space.\nRelated CMake variables like CATKIN_DEVEL_PREFIX do not exist anymore.\n\nCATKIN_GLOBAL_BIN_DESTINATION: bin\nCATKIN_GLOBAL_INCLUDE_DESTINATION: include\nCATKIN_GLOBAL_LIB_DESTINATION: lib\nCATKIN_GLOBAL_LIBEXEC_DESTINATION: lib\nCATKIN_GLOBAL_SHARE_DESTINATION: share\nCATKIN_PACKAGE_BIN_DESTINATION: lib/${PROJECT_NAME}\nCATKIN_PACKAGE_INCLUDE_DESTINATION: include/${PROJECT_NAME}\nCATKIN_PACKAGE_LIB_DESTINATION: lib\nCATKIN_PACKAGE_SHARE_DESTINATION: share/${PROJECT_NAME}\n\n\n\n\n\nUnit tests¶\nIf you are using gtest:\n\nReplace CATKIN_ENABLE_TESTING with BUILD_TESTING (until alpha 5 this was AMENT_ENABLE_TESTING)\nReplace catkin_add_gtest with ament_add_gtest\nAdd <test_depend>ament_cmake_gtest</test_depend> to your package.xml.\n\n\n\nLinters¶\nIn ROS 2.0 we are working to maintain clean code using linters.\nThe styles for different languages are defined in our Developer Guide.\nIf you are starting a project from scratch it is recommended to follow the style guide and turn on the automatic linter unittests by adding these lines just below if(BUILD_TESTING) (until alpha 5 this was AMENT_ENABLE_TESTING).\nfind_package(ament_lint_auto REQUIRED)\nament_lint_auto_find_test_dependencies()\n\n\nYou will also need to add the following dependencies to your package.xml:\n<test_depend>ament_lint_auto</test_depend>\n<test_depend>ament_lint_common</test_depend>\n\n\n\n\nContinue to use catkin in CMake¶\nROS 2 uses ament as the build system but for backward compatibility ROS 2 has a package called catkin which provides almost the same API as catkin in ROS 1.\nIn order to use this backward compatibility API the CMakeLists.txt must only be updated to call the function catkin_ament_package() after all targets.\nNOTE: This has not been implemented yet and is only an idea at the moment.\nDue to the amount of changes related to dependencies it has not yet been decided if this compatibility API is useful enough to justify the effort.\n\n\n\nUpdate source code¶\n\nMessages and services¶\nThe namespace of ROS 2 messages and services uses a subnamespace (msg or srv) after the package name.\nTherefore an include looks like: #include <my_interfaces/msg/my_message.hpp>.\nThe C++ type is then named: my_interfaces::msg::MyMessage.\nShared pointer types are provided as typedefs within the message structs: my_interfaces::msg::MyMessage::SharedPtr as well as my_interfaces::msg::MyMessage::ConstSharedPtr.\nFor more details please see the article about the generated C++ interfaces.\nThe migration requires includes to change by:\n\ninserting the subfolder msg between the package name and message datatype\nchanging the included filename from CamelCase to underscore separation\nchanging from *.h to *.hpp\n\n// ROS 1 style is in comments, ROS 2 follows, uncommented.\n// # include <geometry_msgs/PointStamped.h>\n#include <geometry_msgs/msg/point_stamped.hpp>\n\n// geometry_msgs::PointStamped point_stamped;\ngeometry_msgs::msg::PointStamped point_stamped;\n\n\nThe migration requires code to insert the msg namespace into all instances.\n\n\nUse of service objects¶\nService callbacks in ROS 2 do not have boolean return values.\nInstead of returning false on failures, throwing exceptions is recommended.\n// ROS 1 style is in comments, ROS 2 follows, uncommented.\n// #include \"nav_msgs/GetMap.h\"\n#include \"nav_msgs/srv/get_map.hpp\"\n\n// bool service_callback(\n//   nav_msgs::GetMap::Request & request,\n//   nav_msgs::GetMap::Response & response)\nvoid service_callback(\n  const std::shared_ptr<nav_msgs::srv::GetMap::Request> request,\n  std::shared_ptr<nav_msgs::srv::GetMap::Response> response)\n{\n  // ...\n  // return true;  // or false for failure\n}\n\n\n\n\nUsages of ros::Time¶\nTODO There is no direct replacement for ros::Time yet we expect to have one in the future.\nUnder the hood we expect to leverage the cross platform std::chrono library.\nCurrently for usages of ros::Time:\n\nReplace all instances of ros::Time with builtin_interfaces::msg::Time\nRonvert all instances of nsec to nanosec\nConvert all single argument double constructors to bare constructor plus assignment\n\nField values do not get initialized to zero when constructed.\nYou must make sure to set all values instead of relying on them to be zero.\nAlternatively you can switch to an internal proxy datatype temporarily while waiting for an rclcpp::Time\n\n\nUsages of ros::Rate¶\nThere is an equivalent type rclcpp::Rate object which is basically a drop in replacement for ros::Rate.\n\n\nROS client library¶\n\n\nPython Migration guide from ROS 1\n\n\n\n\nNOTE: Others to be written\n\n\nBoost¶\nMuch of the functionality previously provided by Boost has been integrated into C++11.\nAs such we would like to take advantage of the new core features and avoid the dependency on boost where possible.\n\nShared Pointers¶\nTo switch shared pointers from boost to C++11 replace instances of:\n\n#include <boost/shared_ptr.hpp> with <memory>\nboost::shared_ptr with std::shared_ptr\n\nThere may also be variants such as weak_ptr which you want to convert as well.\nAlso it is recommended practice to use using instead of typedef.\nusing has the ability to work better in templated logic.\nFor details see here\n\n\nThread/Mutexes¶\nAnother common part of boost used in ROS codebases are mutexes in boost::thread.\n\nReplace boost::mutex::scoped_lock with std::unique_lock<std::mutex>\nReplace boost::mutex with std::mutex\nReplace #include <boost/thread/mutex.hpp> with #include <mutex>\n\n\n\nUnordered Map¶\nReplace:\n\n#include <boost/unordered_map.hpp> with #include <unordered_map>\nboost::unordered_map with std::unordered_map\n\n\n\nfunction¶\nReplace:\n\n#include <boost/function.hpp>  with #include <functional>\nboost::function with std::function\n\n\n\n\n\n\nLaunch files¶\nWhile launch files in ROS 1 are specified using .xml files ROS 2 uses Python scripts to enable more flexibility (see launch package).\n\n\nExample: Converting an existing ROS 1 package to use ROS 2¶\nLet’s say that we have simple ROS 1 package called talker that uses roscpp\nin one node, called talker.\nThis package is in a catkin workspace, located at ~/ros1_talker.\n\nThe ROS 1 code¶\nHere’s the directory layout of our catkin workspace:\n$ cd ~/ros1_talker\n$ find .\n.\n./src\n./src/talker\n./src/talker/package.xml\n./src/talker/CMakeLists.txt\n./src/talker/talker.cpp\n\n\nHere is the content of those three files:\nsrc/talker/package.xml:\n<package>\n  <name>talker</name>\n  <version>0.0.0</version>\n  <description>talker</description>\n  <maintainer email=\"gerkey@osrfoundation.org\">Brian Gerkey</maintainer>\n  <license>Apache 2.0</license>\n  <buildtool_depend>catkin</buildtool_depend>\n  <build_depend>roscpp</build_depend>\n  <build_depend>std_msgs</build_depend>\n  <run_depend>roscpp</run_depend>\n  <run_depend>std_msgs</run_depend>\n</package>\n\n\nsrc/talker/CMakeLists.txt:\ncmake_minimum_required(VERSION 2.8.3)\nproject(talker)\nfind_package(catkin REQUIRED COMPONENTS roscpp std_msgs)\ncatkin_package()\ninclude_directories(${catkin_INCLUDE_DIRS})\nadd_executable(talker talker.cpp)\ntarget_link_libraries(talker ${catkin_LIBRARIES})\ninstall(TARGETS talker\n  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})\n\n\nsrc/talker/talker.cpp:\n#include <sstream>\n#include \"ros/ros.h\"\n#include \"std_msgs/String.h\"\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"talker\");\n  ros::NodeHandle n;\n  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);\n  ros::Rate loop_rate(10);\n  int count = 0;\n  std_msgs::String msg;\n  while (ros::ok())\n  {\n    std::stringstream ss;\n    ss << \"hello world \" << count++;\n    msg.data = ss.str();\n    ROS_INFO(\"%s\", msg.data.c_str());\n    chatter_pub.publish(msg);\n    ros::spinOnce();\n    loop_rate.sleep();\n  }\n  return 0;\n}\n\n\n\nBuilding the ROS 1 code¶\nWe source an environment setup file (in this case for Jade using bash), then we\nbuild our package using catkin_make install:\n. /opt/ros/jade/setup.bash\ncd ~/ros1_talker\ncatkin_make install\n\n\n\n\nRunning the ROS 1 node¶\nIf there’s not already one running, we start a roscore, first sourcing the\nsetup file from our catkin install tree (the system setup file at\n/opt/ros/jade/setup.bash would also work here):\n. ~/ros1_talker/install/setup.bash\nroscore\n\n\nIn another shell, we run the node from the catkin install space using\nrosrun, again sourcing the setup file first (in this case it must be the one\nfrom our workspace):\n. ~/ros1_talker/install/setup.bash\nrosrun talker talker\n\n\n\n\n\nMigrating to ROS 2¶\nLet’s start by creating a new workspace in which to work:\nmkdir ~/ros2_talker\ncd ~/ros2_talker\n\n\nWe’ll copy the source tree from our ROS 1 package into that workspace, where we can modify it:\nmkdir src\ncp -a ~/ros1_talker/src/talker src\n\n\nNow we’ll modify the the C++ code in the node.\nThe ROS 2 C++ library, called rclcpp, provides a different API from that\nprovided by roscpp.\nThe concepts are very similar between the two libraries, which makes the changes\nreasonably straightforward to make.\n\nIncluded headers¶\nIn place of ros/ros.h, which gave us access to the roscpp library API, we\nneed to include rclcpp/rclcpp.hpp, which gives us access to the rclcpp\nlibrary API:\n//#include \"ros/ros.h\"\n#include \"rclcpp/rclcpp.hpp\"\n\n\nTo get the std_msgs/String message definition, in place of\nstd_msgs/String.h, we need to include std_msgs/msg/string.hpp:\n//#include \"std_msgs/String.h\"\n#include \"std_msgs/msg/string.hpp\"\n\n\n\n\nChanging C++ library calls¶\nInstead of passing the node’s name to the library initialization call, we do\nthe initialization, then pass the node name to the creation of the node object\n(we can use the auto keyword because now we’re requiring a C++11 compiler):\n//  ros::init(argc, argv, \"talker\");\n//  ros::NodeHandle n;\n    rclcpp::init(argc, argv);\n    auto node = rclcpp::Node::make_shared(\"talker\");\n\n\nThe creation of the publisher and rate objects looks pretty similar, with some\nchanges to the names of namespace and methods.\nFor the publisher, instead of an integer queue length argument, we pass a\nquality of service (qos) profile, which is a far more flexible way to\ncontrolling how message delivery is handled.\nIn this example, we just pass the default profile rmw_qos_profile_default\n(it’s global because it’s declared in rmw, which is written in C and so\ndoesn’t have namespaces).\n//  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);\n//  ros::Rate loop_rate(10);\n  auto chatter_pub = node->create_publisher<std_msgs::msg::String>(\"chatter\",\n    rmw_qos_profile_default);\n  rclcpp::Rate loop_rate(10);\n\n\nThe creation of the outgoing message is different in both the namespace and the\nfact that we go ahead and create a shared pointer (this may change in the future\nwith more publish API that accepts const references):\n//  std_msgs::String msg;\n  auto msg = std::make_shared<std_msgs::msg::String>();\n\n\nIn place of ros::ok(), we call rclcpp::ok():\n//  while (ros::ok())\n  while (rclcpp::ok())\n\n\nInside the publishing loop, we use the -> operator to access the data field\n(because now msg is a shared pointer):\n//    msg.data = ss.str();\n    msg->data = ss.str();\n\n\nTo print a console message, instead of using ROS_INFO(), we use RCLCPP_INFO() and its various cousins. The key difference is that RCLCPP_INFO() takes a Logger object as the first argument.\n//    ROS_INFO(\"%s\", msg.data.c_str());\n    RCLCPP_INFO(node->get_logger(), \"%s\\n\", msg->data.c_str());\n\n\nPublishing the message is very similar, the only noticeable difference being\nthat the publisher is now a shared pointer:\n//    chatter_pub.publish(msg);\n    chatter_pub->publish(msg);\n\n\nSpinning (i.e., letting the communications system process any pending\nincoming/outgoing messages) is different in that the call now takes the node as\nan argument:\n//    ros::spinOnce();\n    rclcpp::spin_some(node);\n\n\nSleeping using the rate object is unchanged.\nPutting it all together, the new talker.cpp looks like this:\n#include <sstream>\n// #include \"ros/ros.h\"\n#include \"rclcpp/rclcpp.hpp\"\n// #include \"std_msgs/String.h\"\n#include \"std_msgs/msg/string.hpp\"\nint main(int argc, char **argv)\n{\n//  ros::init(argc, argv, \"talker\");\n//  ros::NodeHandle n;\n  rclcpp::init(argc, argv);\n  auto node = rclcpp::Node::make_shared(\"talker\");\n//  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);\n//  ros::Rate loop_rate(10);\n  auto chatter_pub = node->create_publisher<std_msgs::msg::String>(\"chatter\", rmw_qos_profile_default);\n  rclcpp::Rate loop_rate(10);\n  int count = 0;\n//  std_msgs::String msg;\n  auto msg = std::make_shared<std_msgs::msg::String>();\n//  while (ros::ok())\n  while (rclcpp::ok())\n  {\n    std::stringstream ss;\n    ss << \"hello world \" << count++;\n//    msg.data = ss.str();\n    msg->data = ss.str();\n//    ROS_INFO(\"%s\", msg.data.c_str());\n    RCLCPP_INFO(node->get_logger(), \"%s\\n\", msg->data.c_str());\n//    chatter_pub.publish(msg);\n    chatter_pub->publish(msg);\n//    ros::spinOnce();\n    rclcpp::spin_some(node);\n    loop_rate.sleep();\n  }\n  return 0;\n}\n\n\n\n\nChanging the package.xml¶\nStarting with ROS 2, only version 2 of the package.xml format is supported\n(this format is also supported in ROS 1, but isn’t used by all packages).\nWe start by specifying the format version in the package tag:\n<!-- <package> -->\n<package format=\"2\">\n\n\nROS 2 uses a newer version of catkin, called ament_cmake, which we specify in the\nbuildtool_depend tag:\n<!--  <buildtool_depend>catkin</buildtool_depend> -->\n  <buildtool_depend>ament_cmake</buildtool_depend>\n\n\nIn our build dependencies, instead of roscpp we use rclcpp, which provides\nthe C++ API that we use.\nWe additionally depend on rmw_implementation, which pulls in the default\nimplementation of the rmw abstraction layer that allows us to support multiple\nDDS implementations (we should consider restructuring / renaming things so that\nit’s possible to depend on one thing, analogous to roscpp):\n<!--  <build_depend>roscpp</build_depend> -->\n  <build_depend>rclcpp</build_depend>\n  <build_depend>rmw_implementation</build_depend>\n\n\nWe make the same addition in the run dependencies and also update from the\nrun_depend tag to the exec_depend tag (part of the upgrade to version 2 of\nthe package format):\n<!--  <run_depend>roscpp</run_depend> -->\n  <exec_depend>rclcpp</exec_depend>\n  <exec_depend>rmw_implementation</exec_depend>\n<!--  <run_depend>std_msgs</run_depend> -->\n  <exec_depend>std_msgs</exec_depend>\n\n\nWe also need to tell the build tool what kind of package we are, so that it knows how\nto build us.\nBecause we’re using ament and CMake, we add the following lines to declare our\nbuild type to be ament_cmake:\n<export>\n  <build_type>ament_cmake</build_type>\n</export>\n\n\nPutting it all together, our package.xml now looks like this:\n<!-- <package> -->\n<package format=\"2\">\n  <name>talker</name>\n  <version>0.0.0</version>\n  <description>talker</description>\n  <maintainer email=\"gerkey@osrfoundation.org\">Brian Gerkey</maintainer>\n  <license>Apache License 2.0</license>\n<!--  <buildtool_depend>catkin</buildtool_depend> -->\n  <buildtool_depend>ament_cmake</buildtool_depend>\n<!--  <build_depend>roscpp</build_depend> -->\n  <build_depend>rclcpp</build_depend>\n  <build_depend>rmw_implementation</build_depend>\n  <build_depend>std_msgs</build_depend>\n<!--  <run_depend>roscpp</run_depend> -->\n  <exec_depend>rclcpp</exec_depend>\n  <exec_depend>rmw_implementation</exec_depend>\n<!--  <run_depend>std_msgs</run_depend> -->\n  <exec_depend>std_msgs</exec_depend>\n  <export>\n    <build_type>ament_cmake</build_type>\n  </export>\n</package>\n\n\nTODO: show simpler version of this file just using the ``<depend>`` tag, which is\nenabled by version 2 of the package format (also supported in ``catkin`` so,\nstrictly speaking, orthogonal to ROS 2).\n\n\nChanging the CMake code¶\nROS 2 relies on a higher version of CMake:\n#cmake_minimum_required(VERSION 2.8.3)\ncmake_minimum_required(VERSION 3.5)\n\n\nROS 2 relies on the C++11 standard.\nDepending on what compiler you’re using, support for C++11 might not be enabled\nby default.\nUsing gcc 5.3 (which is what is used on Ubuntu Xenial), we need to enable it\nexplicitly, which we do by adding this line near the top of the file:\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n\n\nUsing catkin, we specify the packages we want to build against by passing them\nas COMPONENTS arguments when initially finding catkin itself.\nWith ament_cmake, we find each package individually, starting with ament_cmake\n(and adding our new dependency, rmw_implementation):\n#find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(rmw_implementation REQUIRED)\nfind_package(std_msgs REQUIRED)\n\n\nWe call catkin_package() to auto-generate things like CMake configuration\nfiles for other packages that use our package.\nWhereas that call happens before specifying targets to build, we now call the\nanalogous ament_package() after the targets:\n# catkin_package()\n# At the bottom of the file:\nament_package()\n\n\nSimilarly to how we found each dependent package separately, instead of finding\nthem as parts of catkin, we also need to add their include directories\nseparately (see also ament_target_dependencies() below, which is a more\nconcise and more thorough way of handling dependent packages’ build flags):\n#include_directories(${catkin_INCLUDE_DIRS})\ninclude_directories(${rclcpp_INCLUDE_DIRS}\n                    ${rmw_implementation_INCLUDE_DIRS}\n                    ${std_msgs_INCLUDE_DIRS})\n\n\nWe do the same to link against our dependent packages’ libraries:\n#target_link_libraries(talker ${catkin_LIBRARIES})\ntarget_link_libraries(talker\n                      ${rclcpp_LIBRARIES}\n                      ${rmw_implementation_LIBRARIES}\n                      ${std_msgs_LIBRARIES})\n\n\nTODO: explain how ``ament_target_dependencies()`` simplifies the above steps and\nis also better (also handling ``*_DEFINITIONS``, doing target-specific include\ndirectories, etc.).\nFor installation, catkin defines variables like CATKIN_PACKAGE_BIN_DESTINATION.\nWith ament_cmake, we just give a path relative to the installation root, like bin\nfor executables (this is in part because we don’t yet have an equivalent of rosrun):\n#install(TARGETS talker\n#  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})\ninstall(TARGETS talker RUNTIME DESTINATION bin)\n\n\nPutting it all together, the new CMakeLists.txt looks like this:\n#cmake_minimum_required(VERSION 2.8.3)\ncmake_minimum_required(VERSION 3.5)\nproject(talker)\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n#find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(rmw_implementation REQUIRED)\nfind_package(std_msgs REQUIRED)\n#catkin_package()\n#include_directories(${catkin_INCLUDE_DIRS})\ninclude_directories(${rclcpp_INCLUDE_DIRS}\n                    ${rmw_implementation_INCLUDE_DIRS}\n                    ${std_msgs_INCLUDE_DIRS})\nadd_executable(talker talker.cpp)\n#target_link_libraries(talker ${catkin_LIBRARIES})\ntarget_link_libraries(talker\n                      ${rclcpp_LIBRARIES}\n                      ${rmw_implementation_LIBRARIES}\n                      ${std_msgs_LIBRARIES})\n#install(TARGETS talker\n#  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})\ninstall(TARGETS talker RUNTIME DESTINATION bin)\nament_package()\n\n\nTODO: Show what this would look like with ``ament_auto``.\n\n\nBuilding the ROS 2 code¶\nWe source an environment setup file (in this case the one generated by following\nthe ROS 2 installation tutorial, which builds in ~/ros2_ws, then we build our\npackage using colcon build:\n. ~/ros2_ws/install/setup.bash\ncd ~/ros2_talker\ncolcon build\n\n\n\n\nRunning the ROS 2 node¶\nBecause we installed the talker executable into bin, after sourcing the\nsetup file, from our install tree, we can invoke it by name directly\n(also, there is not yet a ROS 2 equivalent for rosrun):\n. ~/ros2_ws/install/setup.bash\ntalker\n\n\n\n\n\n\nLicensing¶\nIn ROS 2 our recommended license is the Apache 2.0 License\nIn ROS 1 our recommended license was the 3-Clause BSD License\nFor any new project we recommend using the Apache 2.0 License, whether ROS 1 or ROS 2.\nHowever when migrating code from ROS 1 to ROS 2 we cannot simply change the license, the existing license must be preserved for any preexisting contributions.\nTo that end if a package is being migrated we recommend keeping the existing license and continuing to contributing to that package under the existing OSI license, which we expect to be the BSD license for core elements.\nThis will keep things clear and easy to understand.\n\nChanging the License¶\nIt is possible to change the license, however you will need to contact all the contributors and get permission.\nFor most packages this is likely to be a significant effort and not worth considering.\nIf the package as a small set of contributors then this may be feasible.\n\n\n\n"},{"id":35,"url":"/doc/ros2/Contributing/CI-Server-Setup/","title":"How to setup the Jenkins master","content":"\nHow to setup the Jenkins master¶\n\nTable of Contents\n\nInstalling\nRunning on port 80\nTemporary rewrite for changed job name\nInstall stuff (needed on master and slaves)\nAdding a Linux slave to the farm\nConfiguring Jenkins\nAuthentication\nPlugins\nAdding an ssh key\n\n\nCreating Jobs\nTuning Auto-generated Jobs\n\n\nDisk space\n\n\n\nInstalling¶\nInstall the latest LTS release from http://pkg.jenkins-ci.org/debian-stable/\n\n\nRunning on port 80¶\nI used this SO answer to setup a subdomain to a port:\nhttp://serverfault.com/a/140161/186748\nI had to remove the hudson in each of the lines that contained it.\n\n\nTemporary rewrite for changed job name¶\nWe renamed some of the jobs, so I added rewrite rules in Apache (/etc/apache2/sites-enabled/ci.ros2.org.conf):\n# Temporary rewrite rule because we changed the Windows job name.\nRewriteEngine On\nRewriteRule ^(.*)/ros2_batch_ci_linux/(.*)$ $1/ci_linux/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_osx/(.*)$ $1/ci_osx/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_windows/(.*)$ $1/ci_windows_opensplice/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_windows_opensplice/(.*)$ $1/ci_windows_opensplice/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_windows_connext_static/(.*)$ $1/ci_windows_connext_static/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_windows_connext_dynamic/(.*)$ $1/ci_windows_connext_dynamic/$2 [R=301,L]\nRewriteRule ^(.*)/ci_windows_opensplice/(.*)$ $1/ci_windows/$2 [R=301,L]\nRewriteRule ^(.*)/ci_windows_connext_static/(.*)$ $1/old_windows_connext_static/$2 [R=301,L]\nRewriteRule ^(.*)/ci_windows_connext_dynamic/(.*)$ $1/old_windows_connext_dynamic/$2 [R=301,L]\nRewriteRule ^(.*)/ci_windows_fastrtps/(.*)$ $1/old_windows_fastrtps/$2 [R=301,L]\n\nRewriteRule ^(.*)/ros2_batch_ci_linux_nightly/(.*)$ $1/nightly_linux/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_osx_nightly/(.*)$ $1/nightly_osx/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_windows_opensplice_nightly/(.*)$ $1/nightly_windows_opensplice/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_windows_connext_static_nightly/(.*)$ $1/nightly_windows_connext_static/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_batch_ci_windows_connext_dynamic_nightly/(.*)$ $1/nightly_windows_connext_dynamic/$2 [R=301,L]\nRewriteRule ^(.*)/nightly_windows_opensplice/(.*)$ $1/nightly_windows/$2 [R=301,L]\nRewriteRule ^(.*)/nightly_windows_connext_static/(.*)$ $1/old_night_windows_connext_static/$2 [R=301,L]\nRewriteRule ^(.*)/nightly_windows_connext_dynamic/(.*)$ $1/old_night_windows_connext_dynamic/$2 [R=301,L]\n\nRewriteRule ^(.*)/ros2_packaging_linux/(.*)$ $1/packaging_linux/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_packaging_osx/(.*)$ $1/packaging_osx/$2 [R=301,L]\nRewriteRule ^(.*)/ros2_packaging_windows_opensplice/(.*)$ $1/packaging_windows_opensplice/$2 [R=301,L]\nRewriteRule ^(.*)/packaging_windows_opensplice/(.*)$ $1/packaging_windows/$2 [R=301,L]\n\n\n\n\nInstall stuff (needed on master and slaves)¶\nsudo apt update\nsudo apt install -y git\n# Your java version will vary depending on your OS:\n#sudo apt install openjdk-7-jre-headless\n#sudo apt install openjdk-8-jre-headless\n# For ARM native servers, we need the tomcat native libs to support ssh-agent\n# (https://issues.jenkins-ci.org/browse/JENKINS-30746)\n#sudo apt install libtcnative-1\n# qemu and vcs are required for ARM builds\nsudo apt install -y qemu-user-static\nsudo bash -c 'echo \"deb http://repositories.ros.org/ubuntu/testing/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list'\nsudo bash -c 'curl --silent http://repositories.ros.org/repos.key |sudo apt-key add -'\n# Or, on aarch64:\n#sudo apt install docker.io\nsudo apt update\nsudo apt install -y python-vcstool\ncurl -fsSL https://get.docker.com/ | sh\nsudo adduser --disabled-password jenkins\nsudo usermod -aG docker jenkins\nsudo service docker start\n\n\n\n\nAdding a Linux slave to the farm¶\nApproximately:\n\nShell into the master (ci.ros2.org), copy /var/lib/jenkins/.ssh/id_rsa.pub and paste it into /home/jenkins/.ssh/authorized_keys on the new machine.\nCopy config from the linux 2 machine, rename and otherwise modify as needed (e.g., change the IP/host).\nCopy /etc/ssh/ssh_host_rsa_key.pub from the new machine and add it as an entry in /var/lib/jenkins/.ssh/known_hosts (with the new machine’s IP) on the master, then re-hash that file on the master: ssh-keygen -H.\n\n\n\nConfiguring Jenkins¶\nFirst I updated all the preinstalled plugins.\n\nAuthentication¶\nThen I setup authentication with the github-oauth plugin.\nI just installed it and followed their setup instructions:\nhttps://wiki.jenkins-ci.org/display/JENKINS/Github+OAuth+Plugin\nI created an application entry on the ros2 GitHub organization:\nhttps://github.com/organizations/ros2/settings/applications/215300\nI also tuned the permissions in Manage Jenkins->Configure Global Security.\n\n\nPlugins¶\nNext I installed all of these plugins:\n\nansicolor\ndescription-setter\ngithub (other git* plugins are deps of the github-oauth plugin)\ngreenballs\ngroovy\nparameterized-trigger\nPrioritySorter\njobrequeue\nssh-agent\nwarnings\nxunit\n\n\n\nAdding an ssh key¶\nJenkins needs a valid ssh key in order to pull from some of our private repositories, for example to get the rti deb files.\nSo I created an ssh key for the jenkins user on the webserver:\nsudo su jenkins\ncd\nmkdir .ssh\nssh-keygen -t rsa\n\n\nThen I added to the jenkins credentials as an “From the jenkins master ~/.ssh” with the user id of ros2-buildfarm.\nI added this key to a “machine” GitHub account that I created for this farm and I added that user, ros2-buildfarm, to the ros2, ament, and osrf organizations.\n\n\n\nCreating Jobs¶\nI cloned the ros2/ci repository to the default branch (master):\ngit clone https://github.com/ros2/ci.git\n\n\nThen I cloned the ros_buildfarm repository:\ngit clone https://github.com/ros-infrastructure/ros_buildfarm.git\n\n\nI also install the jenkinsapi and EmPy Python packages:\nsudo apt install python3-pip\nsudo -H python3 -m pip install -U pip\nsudo -H python3 -m pip install jenkinsapi EmPy\n\n\nThen I setup auth:\nmkdir -p ~/.buildfarm\nvim ~/.buildfarm/jenkins.ini\n\n\nPut this in the jenkins.ini file:\n[http://ci.ros2.org]\nusername=wjwwood\npassword=<your application token>\n\n\nNow, you should first login with GitHub on Jenkins if you haven’t already.\nThen put your github username in and for the application token, browse to the configuration of your user on Jenkins:\nhttp://ci.ros2.org/user/wjwwood/configure\nIn those settings there should be a field called API Token.\nCopy that field for your password.\nNow I can create the jobs:\n$ PYTHONPATH=`pwd`/../ros_buildfarm ./create_jenkins_job.py -u http://ci.ros2.org\nConnecting to Jenkins 'http://ci.ros2.org'\nConnected to Jenkins version '1.617'\nCreating job 'ros2_batch_ci_windows'\nThe Jenkins master does not require a crumb\nCreating job 'ros2_batch_ci_osx'\nCreating job 'ros2_batch_ci_linux'\nCreating job 'ros2_batch_ci_launcher'\n\n\n\nTuning Auto-generated Jobs¶\nThe final step is to fine tune the jobs.\nFor each job you’ll want to check the ssh key being used for the git clone (only on Linux) and the ssh-agent.\nIt should be set to the ssh key setup in the previous steps for the jenkins user.\nI also updated the slaves which the jobs will run on to make sure they matched the names of the slaves I added for Linux, OS X and Windows.\n\n\n\nDisk space¶\nOver time docker images and particularly containers will pile up.\nTo clean up use:\ndocker rm $(docker ps -a -q)\ndocker rmi $(docker images -q -f dangling=true)\n\n\nfrom https://www.calazan.com/docker-cleanup-commands/\n\n\n"}]