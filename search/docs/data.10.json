[{"id":40,"url":"/doc/ros2/Installation/OSX-Install-Binary/","title":"Installing ROS 2 on OS X","content":"\nInstalling ROS 2 on OS X¶\n\nTable of Contents\n\nSystem requirements\nInstalling prerequisites\nDisable System Integrity Protection (SIP)\nDownloading ROS 2\nInstall additional DDS implementations (optional)\nEnable OpenSplice support\nEnable Connext support\n\n\nSet up the ROS 2 environment\nTry some examples\n\n\nThis page explains how to install ROS 2 on OS X from a pre-built binary package.\n\nSystem requirements¶\nWe support OS X El Capitan and Sierra (10.11.x and 10.12.x).\n\n\nInstalling prerequisites¶\nYou need the following things installed before installing ROS 2.\n\nbrew (needed to install more stuff; you probably already have this):\n\nFollow installation instructions at http://brew.sh/\n\nOptional: Check that brew is happy with your system configuration by running:\n  brew doctor\n\n\nFix any problems that it identifies.\n\n\n\n\n\nUse brew to install more stuff:\nbrew install python3\n\n# install asio for Fast-RTPS\nbrew install asio\n\n# install tinyxml2 for Fast-RTPS\n# currently, the binary installation only supports v6.2\n# make sure remove an existing newer version\nbrew remove tinyxml2\nbrew install osrf/simulation/tinyxml2@6.2.0\nbrew link --force tinyxml2@6.2.0\n\n# install dependencies for robot state publisher\nbrew install tinyxml eigen pcre poco\n\n# OpenCV isn't a dependency of ROS 2, but it is used by some demos.\nbrew install opencv\n\n# install OpenSSL for DDS-Security\nbrew install openssl\n\n# install Qt for RViz\nbrew install qt freetype assimp\n\n\n\nInstall rqt dependencies\nbrew install sip pyqt5\nFix some path names when looking for sip stuff during install (see ROS 1 wiki):\nln -s /usr/local/share/sip/Qt5 /usr/local/share/sip/PyQt5\nbrew install graphviz\npython3 -m pip install pygraphviz pydot\n\nInstall additional runtime dependencies for command-line tools:\npython3 -m pip install catkin_pkg empy git+https://github.com/lark-parser/lark.git@0.7d pyparsing pyyaml setuptools argcomplete\n\n\n\n\n\n\nDisable System Integrity Protection (SIP)¶\nOS X versions >=10.11 have System Integrity Protection enabled by default.\nSo that SIP doesn’t prevent processes from inheriting dynamic linker environment variables, such as DYLD_LIBRARY_PATH, you’ll need to disable it following these instructions.\n\n\nDownloading ROS 2¶\n\nGo to the releases page: https://github.com/ros2/ros2/releases\n\nDownload the latest package for OS X; let’s assume that it ends up at ~/Downloads/ros2-package-osx-x86_64.tar.bz2.\n\nNote: there may be more than one binary download option which might cause the file name to differ.\n\n\nUnpack it:\nmkdir -p ~/ros2_install\ncd ~/ros2_install\ntar xf ~/Downloads/ros2-package-osx-x86_64.tar.bz2\n\n\n\n\n\n\nInstall additional DDS implementations (optional)¶\nROS 2 builds on top of DDS.\nIt is compatible with multiple DDS or RTPS (the DDS wire protocol) vendors.\nFor ROS 2 Bouncy and newer:\nThe package you downloaded has been built with optional support for three vendors.\nRun-time support for eProsima’s Fast RTPS is included bundled by default.\nIf you would like to use one of the other vendors you will need to install their software separately.\nFor ROS 2 Ardent and older:\nIf you downloaded a package that includes support for OpenSplice, you must install OpenSplice as detailed below.\n\nEnable OpenSplice support¶\nDownload the latest release from https://github.com/ADLINK-IST/opensplice/releases and unpack it.\nFor ROS 2 releases up to and including Ardent, do not do anything else at this point.\nFor ROS 2 releases later than Ardent, set the OSPL_HOME environment variable to the unpacked directory that contains the release.com script.\n\n\nEnable Connext support¶\nTo use RTI Connext you will need to have obtained a license from RTI.\nYou can install the OS X package of Connext version 5.3.1 provided by RTI from their downloads page.\nAfter installing, run RTI launcher and point it to your license file.\nSet the NDDSHOME environment variable:\nexport NDDSHOME=/Applications/rti_connext_dds-5.3.1\n\n\nYou may need to increase shared memory resources following https://community.rti.com/kb/osx510.\nIf you want to install the Connext DDS-Security plugins please refer to this page.\n\n\n\nSet up the ROS 2 environment¶\nSource the ROS 2 setup file:\n. ~/ros2_install/ros2-osx/setup.bash\n\n\nFor ROS 2 releases up to and including Ardent, if you downloaded a release with OpenSplice support you must additionally source the OpenSplice setup file manually (this is done automatically for ROS 2 releases later than Ardent).\nOnly do this after you have sourced the ROS 2 one:\n. <path_to_opensplice>/x86_64.darwin10_clang/release.com\n\n\n\n\nTry some examples¶\nIn one terminal, set up the ROS 2 environment as described above and then run a talker:\nros2 run demo_nodes_cpp talker\n\n\nIn another terminal, set up the ROS 2 environment and then run a listener:\nros2 run demo_nodes_cpp listener\n\n\nYou should see the talker saying that it’s Publishing messages and the listener saying I heard those messages.\nHooray!\nIf you have installed support for an optional vendor, see this page for details on how to use that vendor.\nIf you run into issues, see the troubleshooting section on the source installation page.\n\n\n"},{"id":41,"url":"/doc/ros2/Releases/Release-Ardent-Apalone/","title":"ROS 2 Ardent Apalone (codename ‘ardent’; December 2017)","content":"\nROS 2 Ardent Apalone (codename ‘ardent’; December 2017)¶\nWelcome to the first non-beta release of ROS 2 software named Ardent Apalone!\n\nSupported Platforms¶\nThis version of ROS 2 is supported on three platforms:\n\nUbuntu 16.04 (Xenial)\nMac OS X 10.12 (Sierra)\nWindows 10\n\nBinary packages as well as instructions for how to compile from source are provided for all 3 platforms (see install instructions as well as documentation).\n\n\nFeatures¶\n\nNew features in this ROS 2 release¶\n\nDistributed discovery, publish / subscribe, request / response communication\nProvided by a C API\nImplemented using different vendors:\neProsima’s FastRTPS as well as ADLINK’s OpenSplice (from binary and source)\nRTI’s Connext (only from source)\n\n\nNumerous quality of service settings for handling non-ideal networks\nDDS Security support (with Connext and FastRTPS)\n\n\nC++ and Python 3 client libraries\nSharing common code in C to unify the implementation\nExecution model separated from the nodes, composable nodes\nNode-specific parameters (only in C++ atm)\nLife cycle (only in C++ atm)\nOptionally intra-process communication using the same API (only in C++)\n\n\nMessage definitions (with bounded arrays and strings as well as default values)\nCommand line tools (e.g. ros2 run)\nrviz with a few display types (the Windows version will likely follow in a few weeks)\nFile system-based resource index (querying information without recursive crawling)\nRealtime safe code paths for pub / sub (with compatible DDS implementations only)\nBridge between ROS 1 and ROS 2\nHSR demo see Beta 3\nTurtlebot demo see Beta 2\n\nFor a more detailed description please see the Features page.\n\n\nChanges since Beta 3 release¶\nImprovements since the Beta 3 release:\n\nrviz\nDifferent initialization options for message data structures in C++ (see design doc)\nLogging API improvements, now also used in the demos\nTime support in C++ with different clocks\nwait-for-service support in the Python client library\nDraft implementation of REP 149 specifying format 3 of the package manifest files\n\n\n\n\nKnown Issues¶\n\nFastRTPS performance with larger data like the image demo\nUsing Connext it is currently not allowed for two topics with the same base name but different namespaces to have a different type (see issue).\nListing of node names (e.g. using ros2 node list) does not work across some rmw implementations.\nOn Windows Python launch files might hang when trying to abort using Ctrl-C (see issue). In order to continue using the shell which is blocked by the hanging command you might want to end the hanging Python process using the process monitor.\n\n\n\n"},{"id":42,"url":"/doc/ros2/Concepts/ROS-2-Client-Libraries/","title":"About ROS2 client libraries","content":"\nAbout ROS2 client libraries¶\n\nTable of Contents\n\nOverview\nSupported client libraries\nCommon functionality: the RCL\nLanguage-specific functionality\nDemo\nComparison to ROS 1\nSummary\n\n\n\nOverview¶\nClient libraries are the APIs that allow users to implement their ROS code.\nThey are what users use to get access to ROS concepts such as nodes, topics, services, etc.\nClient libraries come in a variety of programming languages so that users may write ROS code in the language that is best-suited for their application.\nFor example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++.\nNodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS interface files in the respective language.\nIn addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS “ROS”.\nFor example, here is a list of functionality that can typically be accessed through a client library:\n\nNames and namespaces\nTime (real or simulated)\nParameters\nConsole logging\nThreading model\nIntra-process communication\n\n\n\nSupported client libraries¶\nThe C++ client library (rclcpp) and the Python client library (rclpy) are both client libraries which utilize common functionality in the RCL.\nWhile the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community have created additional client libraries:\n\nJVM and Android\nObjective C and iOS\nC#\nSwift\nNode.js\nAda\n\n\n\nCommon functionality: the RCL¶\nMost of the functionality found in a client library is not specific to the programming language of the client library.\nFor example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages.\nBecause of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific.\nAs a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces.\nThis keeps client libraries thinner and easier to develop.\nFor this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap.\nIn addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent.\nIf any changes are made to the logic/behavior of the functionality in the core RCL – namespaces, for example – all client libraries that use the RCL will have these changes reflected.\nFurthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes.\nThe API documentation for the RCL can be found here.\n\n\nLanguage-specific functionality¶\nClient library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library.\nFor example, threading models used by “spin” functions will have implementations that are specific to the language of the client library.\n\n\nDemo¶\nFor a walkthrough of the message exchange between a publisher using rclpy and a subscriber using rclcpp, we encourage you to watch this ROSCon talk starting at 17:25 (here are the slides).\n\n\nComparison to ROS 1¶\nIn ROS 1, all client libraries are developed “from the ground up”.\nThis allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code.\nHowever, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS).\n\n\nSummary¶\nBy utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior.\n\n\n"},{"id":43,"url":"/doc/ros2/Releases/Release-Crystal-Clemmys/","title":"ROS 2 Crystal Clemmys (codename ‘crystal’; December 2018)","content":"\nROS 2 Crystal Clemmys (codename ‘crystal’; December 2018)¶\n\nTable of Contents\n\nSupported Platforms\nNew features in this ROS 2 release\nChanges since the Bouncy release\nKnown Issues\n\n\nCrystal Clemmys is the third release of ROS 2.\n\nSupported Platforms¶\nCrystal Clemmys is primarily supported on the following platforms (see REP 2000 for full details):\nTier 1 platforms:\n\nUbuntu 18.04 (Bionic)\nMac OS X 10.12 (Sierra)\nWindows 10\n\nTier 2 platforms:\n\nUbuntu 16.04 (Xenial)\n\n\n\nNew features in this ROS 2 release¶\n\nActions in C / C++ (server / client examples)\ngazebo_ros_pkgs\nimage_transport\nnavigation2\nrosbag2\nrqt\nImprovement in memory management\nIntrospection information about nodes\nLaunch system improvements\nArguments\nNested launch files\nConditions\nPass params to Nodes\n\n\nLaid the groundwork for file-based logging and /rosout publishing\nTime and Duration API in Python\nParameters work with Python nodes\n\n\n\nChanges since the Bouncy release¶\nChanges since the Bouncy Bolson release:\n\ngeometry2 - tf2_ros::Buffer API Change\ntf2_ros::Buffer now uses rclcpp::Time, with the constructor requiring a shared_ptr to a rclcpp::Clock instance.\nSee https://github.com/ros2/geometry2/pull/67 for details, with example usage:\n#include <tf2_ros/transform_listener.h>\n#include <rclcpp/rclcpp.hpp>\n...\n# Assuming you have a rclcpp::Node my_node\ntf2_ros::Buffer buffer(my_node.get_clock());\ntf2_ros::TransformListener tf_listener(buffer);\n\n\n\nAll rclcpp and rcutils logging macros require semicolons.\nSee https://github.com/ros2/rcutils/issues/113 for details.\n\nrcutils_get_error_string_safe() and rcl_get_error_string_safe() have been replaced with rcutils_get_error_string().str and rcl_get_error_string().str.\nSee https://github.com/ros2/rcutils/pull/121 for details.\n\nrmw - rmw_init API Change\nThere are two new structs, the rcl_context_t and the rcl_init_options_t, which are used with rmw_init.\nThe init options struct is used to pass options down to the middleware and is an input to rmw_init.\nThe context is a handle which is an output of rmw_init function is used to identify which init-shutdown cycle each entity is associated with, where an “entity” is anything created like a node, guard condition, etc.\nThis is listed here because maintainers of alternative rmw implementations will need to implement these new functions to have their rmw implementation work in Crystal.\nThis is the function that had a signature change:\n\nrmw_init\n\nAdditionally, there are these new functions which need to be implemented by each rmw implementation:\n\nrmw_shutdown\nrmw_init_options_init\nrmw_init_options_copy\nrmw_init_options_fini\n\nHere’s an example of what minimally needs to be changed in an rmw implementation to adhere to this API change:\n\nrmw_fastrtps pr\n\n\nrcl - rcl_init API Change\nLike the rmw change above, there’s two new structs in rcl called rcl_context_t and rcl_init_options_t.\nThe init options are passed into rcl_init as an input and the context is passed in as an output.\nThe context is used to associate all other rcl entities to a specific init-shutdown cycle, effectively making init and shutdown no longer global functions, or rather those functions no longer use an global state and instead encapsulate all state within the context type.\nAny maintainers of a client library implementation (that also uses rcl under the hood) will need to make changes to work with Crystal.\nThese functions were removed:\n\nrcl_get_global_arguments\nrcl_get_instance_id\nrcl_ok\n\nThese functions had signature changes:\n\nrcl_init\nrcl_shutdown\nrcl_guard_condition_init\nrcl_guard_condition_init_from_rmw\nrcl_node_init\nrcl_timer_init\n\nThese are the new functions and types:\n\nrcl_context_t\nrcl_get_zero_initialized_context\nrcl_context_fini\nrcl_context_get_init_options\nrcl_context_get_instance_id\nrcl_context_is_valid\nrcl_init_options_t\nrcl_get_zero_initialized_init_options\nrcl_init_options_init\nrcl_init_options_copy\nrcl_init_options_fini\nrcl_init_options_get_rmw_init_options\nrcl_node_is_valid_except_context\nrcl_publisher_get_context\nrcl_publisher_is_valid_except_context\n\nThese new and changed functions will impact how you handle init and shutdown in your client library.\nFor examples, look at the following rclcpp and rclpy PR’s:\n\nrclcpp\nrclpy\n\nHowever, you may just continue to offer a single, global init and shutdown in your client library, and just store a single global context object.\n\n\n\n\nKnown Issues¶\n\nCross-vendor communication between rmw_fastrtps_cpp and other implementations is not functioning on Windows (Issue).\n100% CPU usage in Action Server when cancelling a goal from the client. (Issue).\nAction Server can crash when a goal expires. (Pull Request).\nSegfault in ros2 param get when a string parameter value contains non-ASCII characters. (Issue).\nThe latest version of OpenSplice on Windows is not compatible with the available binaries. (Issue).\n\n\n\n"}]