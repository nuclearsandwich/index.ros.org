[{"id":80,"url":"/doc/ros2/Contributing/Inter-Sphinx-Support/","title":"Using Sphinx for cross-referencing packages","content":"\nUsing Sphinx for cross-referencing packages¶\n\nTable of Contents\n\nShowing all links of an Intersphinx mapping file\nLinking to other sites using Intersphinx\nExamples of intersphinx in action\n\n\nThis is page provides a quick guide on how you can cross-reference packages documentation within rosindex using Sphinx.\nInventory files must be added to ROSIndex Sphinx’s conf.py file found here. Note that the URI added to the configuration file must point to the directory where the .inv file is rather than to the file itself (i.e: http://docs.ros.org/independent/api/catkin_pkg instead of http://docs.ros.org/independent/api/catkin_pkg/objects.inv).\n\nShowing all links of an Intersphinx mapping file¶\n(Partially borrowed from here).\nTo show all Intersphinx links and their targets of an Intersphinx mapping file, either local or remote, run:\npython -msphinx.ext.intersphinx \"url-or-path-to-inv-file\"\n\n\nThis is helpful when searching for the root cause of a broken Intersphinx link in a documentation project.\n\n\nLinking to other sites using Intersphinx¶\n(Partially borrowed from here).\n\nYou may supply an explicit title and reference target: :role:\\`title <target>\\` will refer to target, but the link text will be title.\nIf you prefix the content with !, no reference/hyperlink will be created.\nIf you prefix the content with ~, the link text will only be the last component of the target. For example, :py:meth:\\`~Queue.Queue.get\\` will refer to Queue.Queue.get but only display get as the link text.\n\n\n\nExamples of intersphinx in action¶\nLinks to source code can be created as follows:\n\nNote\nClass vcstools.VcsClient implements the vcstools.VcsClient.checkout() method.\n\nClass vcstools.VcsClient implements the vcstools.VcsClient.checkout() method.\n\nLinks to documentation pages:\n\nNote\nRefer to vcstools Developer’s Guide document.\n\nRefer to vcstools Developer’s Guide document.\n\nLinks to other pages in this documentation:\n\nNote\nSee the installation page.\n\nSee the installation page.\n\n\n"},{"id":81,"url":"/doc/ros2/Tutorials/tf2/","title":"Using tf2 with ROS 2","content":"\nUsing tf2 with ROS 2¶\nThere is preliminary support for tf2 in ROS 2. We rely heavily on tf2 in ROS 1 to manage data about coordinate transforms, and we expect to continue to use extensively in ROS 2.\nHere’s how to try it out. In each shell, be sure to start by sourcing the ROS 2 setup file as usual (e.g. on Linux . ~/ros2_ws/install/setup.bash or on Windows call C:\\dev\\ros2\\install\\setup.bat).\n\nPublishing transform data¶\nFirst run the static_transform_publisher to generate tf2 data:\nros2 run tf2_ros static_transform_publisher 1 2 3 0.5 0.1 -1.0 foo bar\n\n\nThat tool will publish a static transform from the parent frame foo to the child frame bar with (X, Y, Z) translation (1, 2, 3) and (roll, pitch, yaw) rotation (0.5, 0.1, -1.0).\n\n\nReceiving transform data¶\nNow we can check whether it’s possible to receive that transform data with tf2_echo:\nros2 run tf2_ros tf2_echo foo bar\n\n\nYou should see repeated output similar to this:\nAt time 0.0\n- Translation: [1.000, 2.000, 3.000]\n- Rotation: in Quaternion [-0.475, -0.076, 0.240, 0.843]\n\n\nNote that tf2_echo is reporting the rotation as a quaternion as opposed to roll, pitch, and yaw.\n\n\n"},{"id":82,"url":"/doc/ros2/Tutorials/Working-with-multiple-RMW-implementations/","title":"Working with multiple ROS 2 middleware implementations","content":"\nWorking with multiple ROS 2 middleware implementations¶\n\nTable of Contents\n\nPre-requisites\nMultiple RMW implementations\nDefault RMW implementation\nSpecifying RMW implementations\nAdding RMW implementations to your workspace\nTroubleshooting\n\nEnsuring use of a particular RMW implementation\n\n\n\n\nThis page explains the default RMW implementation and how to specify an alternative.\n\nPre-requisites¶\nYou should have already read the DDS and ROS middleware implementations page.\n\n\nMultiple RMW implementations¶\nThe current ROS 2 binary releases have built-in support for several RMW implementations out of the box (Fast RTPS, RTI Connext Pro, and ADLink OpenSplice at the time of writing), but only Fast RTPS (the default) works without any additional installation steps, because it is the only one we distribute with our binary packages.\nOthers like OpenSplice or Connext can be enabled by installing additional packages, but without having to rebuild anything or replace any existing packages.\nAlso, a ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously.\nWhile the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured.\nFor example, if the code for the RMW package for RTI Connext is in the workspace, it will be built if an installation of RTI’s Connext Pro can also be found.\nFor many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances.\nA list of supported inter-vendor communication configurations is forthcoming.\n\n\nDefault RMW implementation¶\nIf a ROS 2 workspace has multiple RMW implementations, the default RMW implementation is currently selected as Fast RTPS if it’s available.\nIf the Fast RTPS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used.\nThe implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. rmw_fastrtps_cpp.\nFor example, if both rmw_opensplice_cpp and rmw_connext_cpp ROS packages are installed, rmw_connext_cpp would be the default.\nIf rmw_fastrtps_cpp is ever installed, it would be the default.\nSee below for how to specify which RMW implementation is to be used when running the ROS 2 examples.\n\n\nSpecifying RMW implementations¶\nTo have multiple RMW implementations available for use you must have installed our binaries and any additional dependencies for specific RMW implementations, or built ROS 2 from source with multiple RMW implementations in the workspace (they are included by default) and their dependencies are met (for example see the Linux install instructions).\n\nStarting in Beta 2 and above both C++ and Python nodes support an environment variable RMW_IMPLEMENTATION.\nTo choose a different RMW implemenation you can set the environment variable RMW_IMPLEMENTATION to a specific implementation identifier.\nTo run the talker demo using the C++ and listener using python with the RMW implementation for connext:\nBash\nRMW_IMPLEMENTATION=rmw_connext_cpp ros2 run demo_nodes_cpp talker\n\n# Run in another terminal\nRMW_IMPLEMENTATION=rmw_connext_cpp ros2 run demo_nodes_py listener\n\n\nWindows cmd.exe\nset RMW_IMPLEMENTATION=rmw_connext_cpp\nros2 run demo_nodes_cpp talker\n\nREM run in another terminal\nset RMW_IMPLEMENTATION=rmw_connext_cpp\nros2 run demo_nodes_py listener\n\n\n\n\nAdding RMW implementations to your workspace¶\nSuppose that you have built your ROS 2 workspace with only Fast RTPS installed and therefore only the Fast RTPS RMW implementation built.\nThe last time your workspace was built, any other RMW implementation packages, rmw_connext_cpp for example, were probably unable to find installations of the relevant DDS implementations.\nIf you then install an additional DDS implementation, Connext for example, you will need to re-trigger the check for a Connext installation that occurs when the Connext RMW implementation is being built.\nYou can do this by specifying the --force-cmake-configure flag on your next workspace build, and you should see that the RMW implementation package then gets built for the newly installed DDS implementation.\nIt is possible to run into a problem when “rebuilding” the workspace with an additional RMW implementation using the --force-cmake-configure option where the build complains about the default RMW implementation changing.\nTo resolve this, you can either set the default implementation to what is was before with the RMW_IMPLEMENTATION CMake argument or you can delete the build folder for packages that complain and continue the build with --start-with <package name>.\n\n\nTroubleshooting¶\n\nEnsuring use of a particular RMW implementation¶\n\nROS 2 Ardent and later¶\nIf the RMW_IMPLEMENTATION environment variable is set to an RMW implementation for which support is not installed, you will see an error message similar to the following if you have only one implementation installed:\nExpected RMW implementation identifier of 'rmw_connext_cpp' but instead found 'rmw_fastrtps_cpp', exiting with 102.\n\n\nIf you have support for multiple RMW implementations installed and you request use of one that is not installed, you will see something similar to:\nError getting RMW implementation identifier / RMW implementation not installed (expected identifier of 'rmw_connext_cpp'), exiting with 1.\n\n\nIf this occurs, double check that your ROS 2 installation includes support for the RMW implementation that you have specified in the RMW_IMPLEMENTATION environment variable.\n\n\n\n\n"}]