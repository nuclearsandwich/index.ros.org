[{"id":60,"url":"/doc/ros2/Tutorials/RQt-Port-Plugin-Windows/","title":"Porting RQt plugins to Windows","content":"\nPorting RQt plugins to Windows¶\n\nTable of Contents\n\nRQt Porting examples\nConsiderations for Windows 10\n\nTroubles with TinyXML version 1\nCode that uses __cplusplus and code that requires pluginlib\nLocations of build artifacts (before install)\nCompiler and linker flags\n\n\n\n\nRQt has not been historically supported on Windows, but compatibility is happening, slowly.\n\nRQt Porting examples¶\nMicrosoft pushed an effort to port much of ROS to Windows, their repos are a good resource for necessary changes.\nThey live at the ms-iot organization with branches called init-windows.\nFor example: https://github.com/ms-iot/qt_gui_core/tree/init_windows\nHere is the ROS 2 port of qt_gui_core.\nHere is the ROS 2 port of python_qt_binding.\n\n\nConsiderations for Windows 10¶\n\nTroubles with TinyXML version 1¶\nI could not successfully use TinyXML.\nI upgraded to TinyXML-2 where needed.\nIt’s a pretty straight forward change.\nCheckout this PR for an example of porting to TinyXML-2.\n\n\nCode that uses __cplusplus and code that requires pluginlib¶\nIn some places, notably in the ROS 2 port of pluginlib, there is use of the __cplusplus flag.\nUnfortunately on Windows Visual Studio does not set this flag correctly regardless of the C++ standard that is actually being used.\nSee this page for more information.\nTo set it, you need to add the compile option /Zc:__cplusplus.\nFor example, in CMake you could do something like this:\ntarget_compile_options(${PROJECT_NAME} PUBLIC \"/Zc:__cplusplus\")\n\n\n\n\nLocations of build artifacts (before install)¶\nThis only came up during when building qt_gui_cpp.\nIn that package, a custom command depends on a target library in another part of the package.\nHowever, that library isn’t installed until build is complete. Windows builds in a ${configuration} directory.\nFor example:\nOn Linux, qt_gui_cpp.a would be built in:\n<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/\nBut on Windows qt_gui_cpp.lib is built in\n<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/Release\nFor compatibility across platforms in this situation, use CMake generator expressions.\nHowever, when you need a library to link against be sure to use $<TARGET_LINKER_FILE:_target> instead of $<TARGET_FILE:_target>.\nThe latter will find .dll files, which cannot be linked against on Windows.\nSee an example here.\n\n\nCompiler and linker flags¶\nIn general when porting to Windows, many packages might make use of additional compiler flags.\nYou can find the Windows compiler flags on Microsoft’s documentation.\nThe C++ compiler is called cl.exe.\nFor linker flags see Microsoft’s documentation.\nThe linker program is called link.exe.\nHowever, CMake actually provides many of these options in variables.\nThis StackOverflow page contains a good example of how to see all the CMake variables available in a script.\n\n\n\n"},{"id":61,"url":"/doc/ros2/Contributing/Migration-Guide-Python/","title":"Python Migration guide from ROS 1","content":"\nPython Migration guide from ROS 1¶\n\nNode Initialization¶\n# rospy.init_node('asdf')\nrclpy.init(args=sys.argv)\nnode = rclpy.create_node('asdf')\n\n\n\n\nCreating a Publisher¶\n# pub = rospy.Publisher('chatter', String)\npub = node.create_publisher(String, 'chatter')\n\n\n\n\nCreating a Subscriber¶\n# sub = rospy.Subscriber('chatter', String, callback)\nsub = node.create_subscription(String, 'chatter', callback)\n\n\n\n\nCreating a Service¶\n# srv = rospy.Service('add_two_ints', AddTwoInts, add_two_ints_callback)\nsrv = node.create_service(AddTwoInts, 'add_two_ints', add_two_ints_callback)\n\n\n\n\nCreating a Service Client¶\n# rospy.wait_for_service('add_two_ints')\n# add_two_ints = rospy.ServiceProxy('add_two_ints', AddTwoInts)\n# resp = add_two_ints(req)\nadd_two_ints = node.create_client(AddTwoInts, 'add_two_ints')\nwhile not add_two_ints.wait_for_service(timeout_sec=1.0):\n    node.get_logger().info('service not available, waiting again...')\nresp = add_two_ints.call_async(req)\nrclpy.spin_until_future_complete(node, resp)\n\n\n\n\n"},{"id":62,"url":"/doc/ros2/Tutorials/Python-Programming/","title":"Python Programming in ROS 2","content":"\nPython Programming in ROS 2¶\n\nTable of Contents\n\nBackground\nInstall\nRun the examples\nCommunication with nodes using different ROS client libraries\n\n\n\nBackground¶\nOne of the most popular features of ROS 1 is the ability of writing robot applications in a variety of languages. Starting with Alpha 4, ROS 2 provides a Python API that can be used for communicating with other nodes written in different languages.\n\n\nInstall¶\nThe rclpy module enables developers to use the ROS 2 API from Python. As of Alpha 4, rclpy is still under development and its API might change, but for now the basics (publishers and subscriptions) can be accessed from Python.\nrclpy is part of the standard ROS 2 distribution, so it’ll be installed alongside the rest of the ROS 2 packages.\n\n\nRun the examples¶\nThe two classic ROS 2 examples of a “talker” and a “listener” have been implemented in Python using rclpy. The source code is available here.\nOpen two terminals, source the appropriate setup.* / local_setup.* file in the terminals, and run ros2 run demo_nodes_py talker in one and ros2 run demo_nodes_py listener in the other.\nOnce executed you should see the following on the terminal running the listener:\nI heard: [Hello World: 1]\nI heard: [Hello World: 2]\nI heard: [Hello World: 3]\nI heard: [Hello World: 4]\nI heard: [Hello World: 5]\nI heard: [Hello World: 6]\nI heard: [Hello World: 7]\nI heard: [Hello World: 8]\nI heard: [Hello World: 9]\nI heard: [Hello World: 10]\n\n\n\n\nCommunication with nodes using different ROS client libraries¶\nSince rclpy uses the underlying ROS 2 infrastructure, Python programs that use rclpy can also communicate with applications written in C++, even if they use a different DDS vendor and are running on a different operating system.\n\n\n"},{"id":63,"url":"/doc/ros2/Contributing/Quality-Guide/","title":"Quality Guide: Ensuring code quality","content":"\nQuality Guide: Ensuring code quality¶\nThis section tries to give guidance about how to improve the software quality of ROS2 packages. The guide uses a pattern language based approach to improve the readers experience (“read little, understand fast, understand much, apply easily”).\nWhat this sections is about:\n\nROS2 core, application and ecosystem packages.\nROS2 core client libraries C++ and Python (right now: mainly C++)\nDesign and implementation considerations to improve quality attributes like “Reliability”, “Security”, “Maintainability”, “Determinism”, etc. which relate to non-functional requirements (right now: mainly “Reliability”).\n\nWhat this section is not about:\n\nDesign and implementation considerations which go beyond a single ROS2 package and a single ROS2 node (means no integration considerations w.r.t. ROS2 graphs, etc.).\nOrganizational considerations to improve software quality (an organizations structure and processes, etc.).\nInfrastructural considerations which go beyond a single repository (overall continuous integration infrastructure, etc.)\n\nRelation to other sections:\n\nThe Design Guide summarizes design patterns for ROS2 packages. As quality is highly impacted by design it is a good idea to have a look into it before.\nThe Developer Guide explains what to consider when contributing to ROS2 packages w.r.t. to contribution workflow (organizational), coding conventions, documentation considerations, etc. All these consideration may have an impact on single or several quality attributes.\n\n\nPatterns¶\n\nStatic code analysis\n\nStatic code analysis using a single tool\nStatic code analysis using multiple tools complementary\nStatic code analysis as part of the ament package build\n\n\nDynamic code analysis\nROS2 library test\n\n(referencing of generic unit test patterns like from xUnitPatterns with references to C++ gtest+gmock/Python unittest implementations)\n(ROS2 specific unit test use cases)\nProperty based test (C++ RapidCheck / Python hypothesis)\nCode coverage analysis\n\n\nROS2 node unit test\n\n(generic use cases of launch based tests)\n\n\n\n\n\nStatic code analysis as part of the ament package build¶\nContext:\n\nYou have developed your C++ production code.\nYou have created a ROS2 package with build support with ament.\n\nProblem:\n\nLibrary level static code analysis is not run as part of the package build procedure.\nLibrary level static code analysis needs to be executed manually.\nRisk of forgetting to execute library level static code analysis before building\na new package version.\n\nSolution:\n\nUse the integration capabilities of ament to execute static code analysis as\npart of the package build procedure.\n\nImplementation:\n\nInsert into the packages CMakeLists.txt file.\n\n...\nif(BUILD_TESTING)\n  find_package(ament_lint_auto REQUIRED)\n  ament_lint_auto_find_test_dependencies()\n  ...\nendif()\n...\n\n\n\nInsert the ament_lint test dependencies into the packages package.xml file.\n\n...\n<package format=\"2\">\n  ...\n  <test_depend>ament_lint_auto</test_depend>\n  <test_depend>ament_lint_common</test_depend>\n  ...\n</package>\n\n\nExamples:\n\nrclcpp:\n\nrclcpp/rclcpp/CMakeLists.txt\nrclcpp/rclcpp/package.xml\n\n\nrclcpp_lifecycle:\n\nrclcpp/rclcpp_lifecycle/CMakeLists.txt\nrclcpp/rclcpp_lifecycle/package.xml\n\n\n\nResulting context:\n\nThe static code analysis tools supported by ament are run as part of the package build.\nStatic code analysis tools not supported by ament need to be executed separately.\n\n\n\nDynamic analysis (data races & deadlocks)¶\nContext:\n\nYou are developing/debugging your multithreaded C++ production code.\nYou use pthreads or C++11 threading + llvm libc++ (in case of ThreadSanatizer).\nYou do not use Libc/libstdc++ static linking (in case of ThreadSanatizer).\nYou do not build non-position-independent executables (in case of ThreadSanatizer).\n\nProblem:\n\nData races and deadlocks can lead to critical bugs.\nData races and deadlocks cannot be detected using static analysis (reason: limitation of static analysis).\nData races and deadlocks must not show up during development debugging / testing (reason: usually not all possible control paths through production code exercised).\n\nSolution:\n\nUse a dynamic analysis tool which focuses on finding data races and deadlocks (here clang ThreadSanatizer).\n\nImplementation:\n\nCompile and link the production code with clang using the option -fsanitize=thread (this instruments the production code).\nIn case different production code shall be executed during anaylsis consider conditional compilation e.g. ThreadSanatizers _has_feature(thread_sanitizer).\nIn case some code shall not be instrumented consider ThreadSanatizers _/*attribute*/_((no_sanitize(“thread”))).\nIn case some files shall not be instrumented consider file or function level exclusion ThreadSanatizers blacklisting, more specific: ThreadSanatizers Sanitizer Special Case List or with ThreadSanatizers no_sanitize(“thread”) and use the option --fsanitize-blacklist.\n\nResulting context:\n\nHigher chance to find data races and deadlocks in production code before deploying it.\nAnalysis result may lack reliability, tool in beta phase stage (in case of ThreadSanatizer).\nOverhead due to production code instrumentation (maintenance of separate branches for instrumented/not instrumented production code, etc.).\nInstrumented code needs more memory per thread (in case of ThreadSanatizer).\nInstrumented code maps a lot virtual address space (in case of ThreadSanatizer).\n\n\n\nCode coverage analysis¶\nContext\nYou have written tests for the library level production code of a ROS2 package (usually refered to as “unit tests”).\nProblem\nYou do not know how much of the production code is exercised during the execution of the tests.\nSolution\nSelect and use a code coverage analysis tool to determine the code coverage.\nForces\n\nIs it possible to integrate the tool with your source code editor?\nIf not web service based: Is it possible to integrate the tool with your continuous integration infrastructure?\nWhat type(s) of coverage measurements (e.g. statement coverage) does the tool support?\n\nExample\n\nC++\n\ngcov + lcov\ncoveralls.io\n\n\nPython\n\ncoveralls.io\n\n\n\nResulting context\n\nYou know how much of your production code was exercised during the execution of the unit tests.\nYou have a more or less immediate feedback about the code coverage (editor integration / web service front end).\nYou do not know anything about the quality of your tests. (The only way to figure that out is some kind of review).\n\n\n\n"}]