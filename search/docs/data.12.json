[{"id":48,"url":"/doc/ros2/Concepts/Logging/","title":"Logging and logger configuration","content":"\nLogging and logger configuration¶\n\nTable of Contents\n\nOverview\nLogger concepts\nLogging usage\nLogger configuration\n\nCommand line configuration of the default severity level\nProgrammatic configuration of individual loggers\n\n\nConsole output configuration\n\n\n\nOverview¶\nThe logging functionality currently supported is:\n\nClient libraries (rclcpp and rclpy) using a common logging library to provide:\n\nLog calls with a variety of filters.\nHierarchy of loggers.\nLoggers associated with nodes that automatically use the node’s name and namespace.\n\n\nConsole output.\n\nFile output and functionality akin to rosout for remote consumption of messages is forthcoming.\n\n\nProgrammatic configuration of logger levels.\n\nLaunch-time configuration of the default logger level is supported; config files and external configuration at run-time is forthcoming.\n\n\n\n\n\nLogger concepts¶\nLog messages have a severity level associated with them: DEBUG, INFO, WARN, ERROR or FATAL, in ascending order.\nA logger will only process log messages with severity at or higher than a specified level chosen for the logger.\nEach node (in rclcpp and rclpy) has a logger associated with it that automatically includes the node’s name and namespace.\nIf the node’s name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name.\nNon-node loggers can also be created that use a specific name.\nLogger names represent a hierarchy.\nIf the level of a logger named “abc.def” is unset, it will defer to the level of its parent named “abc”, and if that level is also unset, the default logger level will be used.\nWhen the level of logger “abc” is changed, all of its descendants (e.g. “abc.def”, “abc.ghi.jkl”) will have their level impacted unless their level has been explicitly set.\n\n\nLogging usage¶\nIn C++:\n\nSee the logging demo for example usage.\nSee the rclcpp documentation for an extensive list of functionality.\n\nIn Python:\n\nSee the rclpy examples for example usage of a node’s logger.\nSee the rclpy tests for example usage of keyword arguments (e.g. skip_first, once).\n\n\n\nLogger configuration¶\n\nCommand line configuration of the default severity level¶\nAs of the Bouncy ROS 2 release, the default severity level for loggers can be configured from the command line with the following, for example (the level string is not case sensitive):\nros2 run demo_nodes_cpp listener __log_level:=debug\n\n\nThis will affect all loggers that have not explicitly been configured to use a particular severity level.\nConfiguration of specific loggers from the command line is forthcoming.\n\n\nProgrammatic configuration of individual loggers¶\nLogger configuration is still under development.\nFor now, the severity level of individual loggers can be configured programmatically with, e.g.:\nIn C++:\nrcutils_logging_set_logger_level(\"logger_name\", RCUTILS_LOG_SEVERITY_DEBUG);\n\n\nIn Python:\nlogger.set_level(rclpy.logging.LoggingSeverity.DEBUG)\nrclpy.logging.set_logger_level('logger_name', rclpy.logging.LoggingSeverity.DEBUG)\n\n\nThe logging demo provides an example of manually exposing a service so that loggers can be configured externally; in the future we expect runtime configuration capabilities of loggers to be exposed automatically.\n\n\n\nConsole output configuration¶\nBy default, console output will be formatted to include the message severity, logger name, and the message.\nInformation such as the file name, function name and line number of the log call are also available.\nCustom console output format can be configured with the RCUTILS_CONSOLE_OUTPUT_FORMAT environment variable: see the rcutils documentation for details.\nAs rclpy and rclcpp both use rcutils for logging, this will effect all Python and C++ nodes.\n\n\n"},{"id":49,"url":"/doc/ros2/Tutorials/Logging-and-logger-configuration/","title":"Logging and logger configuration demo","content":"\nLogging and logger configuration demo¶\nSee the logging page for details on available functionality.\nIn this demo, different types of log calls are shown and the severity level of different loggers is configured locally and externally.\nStart the demo with:\nros2 run logging_demo logging_demo_main\n\n\nOver time you will see output from various log calls with different properties.\nTo start with you will only see output from log calls with severity INFO and above (WARN, ERROR, FATAL).\nNote that the first message will only be logged once, though the line is reached on each iteration, as that is a property of the log call used for that message.\n\nLogger level configuration: programmatically¶\nAfter 10 iterations the level of the logger will be set to DEBUG, which will cause additional messages to be logged.\nSome of these debug messages cause additional functions/expressions to be evaluated, which were previously skipped as DEBUG log calls were not enabled.\nSee the source code of the demo for further explanation of the calls used, and see the rclcpp logging documentation for a full list of supported logging calls.\n\n\nLogger level configuration: externally¶\nIn the future there will be a generalized approach to external configuration of loggers at runtime (similar to how rqt_logger_level in ROS 1 allows logger configuration via remote procedural calls).\nThis concept is not yet officially supported in ROS 2.\nIn the meantime, this demo provides an example service that can be called externally to request configuration of logger levels for known names of loggers in the process.\nThe demo previously started is already running this example service.\nTo set the level of the demo’s logger back to INFO, call the service with:\nros2 service call /config_logger logging_demo/ConfigLogger \"{logger_name: 'logger_usage_demo', level: INFO}\"\n\n\nThis service call will work on any logger that is running in the process provided that you know its name.\nThis includes the loggers in the ROS 2 core, such as rcl (the common client library package).\nTo enable debug logging for rcl, call:\nros2 service call /config_logger logging_demo/ConfigLogger \"{logger_name: 'rcl', level: DEBUG}\"\n\n\nYou should see debug output from rcl start to show.\n\nUsing the logger config component¶\nThe server that responds to the logger configuration requests has been developed as a component so that it may be added to an existing composition-based system.\nFor example, if you are using a container to run your nodes, to be able to configure your loggers you only need to request that it additionally load the logging_demo::LoggerConfig component into the container.\nAs an example, if you want to debug the composition::Talker demo, you can start the talker as normal with:\nShell 1:\nros2 run composition api_composition\n\n\nShell 2:\nros2 run composition api_composition_cli composition composition::Talker\n\n\nAnd then when you want to enable debug logging, load the LoggerConfig component with:\nShell 2\nros2 run composition api_composition_cli logging_demo logging_demo::LoggerConfig\n\n\nAnd finally, configure all unset loggers to the debug severity by addressing the empty-named logger.\nNote that loggers that have been specifically configured to use a particular severity will not be affected by this call.\nShell 2:\nros2 service call /config_logger logging_demo/ConfigLogger \"{logger_name: '', level: DEBUG}\"\n\n\nYou should see debug output from any previously unset loggers in the process start to appear, including from the ROS 2 core.\n\n\n\nLogger level configuration: command line¶\nAs of the Bouncy ROS 2 release, the severity level for loggers that have not had their severity set explicitly can be configured from the command line.\nRestart the demo including the following command line argument:\nros2 run logging_demo logging_demo_main __log_level:=debug\n\n\nThis configures the default severity for any unset logger to the debug severity level.\nYou should see debug output from loggers from the demo itself and from the ROS 2 core.\nThe ability to configure specific loggers from the command line is forthcoming.\n\nConsole output formatting¶\nIf you would like more or less verbose formatting, you can use the RCUTILS_CONSOLE_OUTPUT_FORMAT environment variable.\nFor example, to additionally get the timestamp and location of the log calls, stop the demo and restart it with the environment variable set:\nexport RCUTILS_CONSOLE_OUTPUT_FORMAT=\"[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"\n# Or, on Windows:\n# set \"RCUTILS_CONSOLE_OUTPUT_FORMAT=[{severity} {time}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})\"\nros2 run logging_demo logging_demo_main\n\n\nYou should see the timestamp in seconds and the function name, filename and line number additionally printed with each message.\nThe ``time`` option is only supported as of the ROS 2 Bouncy release.\n\n\n\n"},{"id":50,"url":"/doc/ros2/Contributing/MISRA-Compliance-Guide/","title":"MISRA Compliance Guide","content":"\nMISRA Compliance Guide¶\nThis section tries to give guidance about how to integrate ROS2 into a system that is intended to be compliant with the MISRA (Motor Industry Software Reliability Association) guidelines.\nWhat this section is about:\n\nROS2 core packages\nROS2 core client libraries\nIntegration considerations for ROS2 packages in a MISRA-Compliant system\n\nWhat this section is not about:\n\nApplying MISRA Guidelines to application and ecosystem ROS2 packages.\nA detailed description of the MISRA Guidelines\n\nRelation to other sections of this wiki:\n\nThe Quality Guide summarizes overall techniques and strategies for producing high quality ROS2 packages.\n\n\nWhat are the MISRA guidelines?¶\nFrom MISRA\n\nMISRA was originally established as a collaboration between vehicle manufacturers, component suppliers and engineering consultancies, and seeks to promote best practice in developing safety-related electronic systems in road vehicles and other embedded systems. To this end MISRA publishes documents that provide accessible information for engineers and management, and holds events to permit the exchange of experiences between practitioners.\n\nMISRA publishes a set of guidelines for both C and C++ that define a subset of the languages that are likely to be free from important programming mistakes for safety-critical systems. The MISRA guidelines are used as a component of various software standards, such as:\n\nISO 26262 - “Road Vehicles - Functional Safety”\nAUTOSAR - Automotive Open System Architecture\n\n\n\nWhy is this important to ROS2 users?¶\nAs robotics and autonomy grow, especially in the field of self-driving cars, users of ROS will need to be able to determine if the software is able to be used in a safety-critical environment. With suitable guidance and modification, it is expected that ROS2 could be integrated as part of a MISRA compliant system. This would enable users of ROS2 to take their work through multiple stages of the software lifecycle, from prototype through production.\n\n\nClaiming Compliance¶\nFrom: MISRA Compliance:2016\n\nIn order for a claim of MISRA compliance to have meaning, it is necessary to establish:\n\nExactly which guidelines are being applied;\nThe effectiveness of the enforcement methods;\nThe extent to which deviations have been used;\nUse of a disciplined software development process;\nThe status of any components developed outside of the project.\n\n\n\n\n"},{"id":51,"url":"/doc/ros2/Installation/Maintaining-a-Source-Checkout/","title":"Maintaining a Source Checkout of ROS 2","content":"\nMaintaining a Source Checkout of ROS 2¶\n\n\nUpdate your repository list\n\nLatest release\nParticular release\nDevelopment branches\n\n\nUpdate your repositories\nDownload the new source code\nRebuild your workspace\nInspecting your source checkout\n\n\nIf you have installed ROS 2 from source, there may have been changes made to the source code since the time that you checked it out.\nTo keep your source checkout up to date, you will have to periodically update your ros2.repos file, download the latest sources, and rebuild your workspace.\n\nUpdate your repository list¶\nEach ROS 2 release includes a ros2.repos file that contains the list of repositories and their version for that release.\n\nLatest release¶\nTo download the repository list from the latest ROS 2 release, run:\nLinux/OS X\ncd ~/ros2_ws\nmv -i ros2.repos ros2.repos.old\nwget https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos\n\n\nWindows\n# CMD\n> cd \\dev\\ros2\n> curl -sk https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos -o ros2.repos\n\n# PowerShell\n> cd \\dev\\ros2\n> curl https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos -o ros2.repos\n\n\n\n\nParticular release¶\nIf you wish to checkout a particular release, you can get its repository list by specifying the name of the release in the url of the following step, e.g. for alpha 7:\nLinux/OS X\ncd ~/ros2_ws\nmv -i ros2.repos ros2.repos.old\nwget https://raw.githubusercontent.com/ros2/ros2/release-alpha8/ros2.repos\n\n\nWindows\n# CMD\n> cd \\dev\\ros2\n> curl -sk https://raw.githubusercontent.com/ros2/ros2/release-alpha8/ros2.repos -o ros2.repos\n\n# PowerShell\n> cd \\dev\\ros2\n> curl https://raw.githubusercontent.com/ros2/ros2/release-alpha8/ros2.repos -o ros2.repos\n\n\nThe format of the name of the release comes from the tag associated with the release here.\n\n\nDevelopment branches¶\nIf you wish to checkout the bleeding-edge development code, you can get the relevant repository list by running:\nLinux/OS X\ncd ~/ros2_ws\nmv -i ros2.repos ros2.repos.old\nwget https://raw.githubusercontent.com/ros2/ros2/master/ros2.repos\n\n\nWindows\n# CMD\n> cd \\dev\\ros2\n> curl -sk https://raw.githubusercontent.com/ros2/ros2/master/ros2.repos -o ros2.repos\n\n# PowerShell\n> cd \\dev\\ros2\n> curl https://raw.githubusercontent.com/ros2/ros2/master/ros2.repos -o ros2.repos\n\n\n\n\n\nUpdate your repositories¶\nYou will notice that in the ros2.repos file, each repository has a version associated with it that points to a particular commit hash, tag, or branch name.\nIt is possible that these versions refer to new tags/branches that your local copy of the repositories will not recognize as they are out-of-date.\nBecause of this, you should update the repositories that you have already checked out with the following command:\nvcs custom --args remote update\n\n\n\n\nDownload the new source code¶\nYou should now be able to download the sources associated with the new repository list with:\nLinux/OS X\nvcs import src < ros2.repos\nvcs pull src\n\n\nWindows\n# CMD\n> vcs import src < ros2.repos\n> vcs pull src\n\n# PowerShell\n> vcs import --input ros2.repos src\n> vcs pull src\n\n\n\n\nRebuild your workspace¶\nNow that the workspace is up to date with the latest sources, remove your previous install and rebuild your workspace with, for example:\ncolcon build --symlink-install\n\n\n\n\nInspecting your source checkout¶\nDuring your development you may have deviated from the original state of your workspace from when you imported the repository list.\nIf you wish to know the versions of the set of repositories in your workspace, you can export the information using the following command:\nLinux/OS X\ncd ~/ros2_ws\nvcs export src > my_ros2.repos\n\n\nWindows\n> cd \\dev\\ros2\n> vcs export src > my_ros2.repos\n\n\nThis my_ros2.repos file can then be shared with others so that they can reproduce the state of the repositories in your workspace.\n\n\n"}]