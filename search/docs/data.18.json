[{"id":72,"url":"/doc/ros2/Tutorials/Defining-custom-interfaces-(msg-srv)/","title":"Defining custom interfaces (msg/srv)","content":"\nDefining custom interfaces (msg/srv)¶\nINCOMPLETE\nWhile we encourage reuse of existing “standard” message and service definitions wherever possible, there are plenty of cases in which you’ll need to define your own custom messages and/or services for a particular application.\nThe first step in defining a custom message or service is to write the .msg or .srv file, which you do using the ROS interface definition language.\nBy convention, .msg files go into a package subdirectory called msg and .srv files go into a package subdirectory called srv (you can pick different locations, but we recommend following the convention).\nHaving written your .msg and/or .srv files, you need to add some code to your package’s CMakelists.txt file to make the code generators run over your definitions. In lieu of a more complete tutorial on this topic, consult the pendulum_msgs package as an example. You can see the relevant CMake calls in that packages’s CMakeLists.txt file.\nNote that the package.xml format must equal 3 for this to build, this is because the member_of_group command requires format 3. ROS2’s create package generates the package.xml with a default format of 2.\n\n"},{"id":73,"url":"/doc/ros2/Tutorials/Releasing-a-ROS-2-package-with-bloom/","title":"Releasing a ROS 2 package with bloom","content":"\nReleasing a ROS 2 package with bloom¶\n\nTable of Contents\n\nIntroduction\nRequired Tools\nEnsure that you have the latest version of bloom and catkin_pkg\n\n\nNo differences from ROS 1 Bloom\nProcedure\nBuild Status\n\n\n\nIntroduction¶\nThis page describes how to prepare a repository for release on the public ROS 2 buildfarm. After you’ve created a package, this is the next step towards getting your package in to the publicly-available Debian packages (i.e., you will be able to install the package via apt). This page includes the ROS 2-specific instructions to execute before following the Bloom release tutorial on the ROS Wiki.\n\n\nRequired Tools¶\nFor ROS 2 Bouncy:\n\nbloom >= 0.6.6\ncatkin_pkg >= 0.4.5\n\nfor ROS 2 Crystal:\n\nbloom >= 0.6.9\ncatkin_pkg >= 0.4.5\n\n\nEnsure that you have the latest version of bloom and catkin_pkg¶\nSee above version requirements.\n\nMake sure you have the ros repositories in your sources (see instructions here).\n\nInstall the latest version of bloom and catkin_pkg:\nsudo apt install python-catkin-pkg python-bloom\n\n\n\n\nIf you’re using a version of bloom older than 0.6.8 you’ll need to use the v3 index url for releasing.\nexport ROSDISTRO_INDEX_URL='https://raw.githubusercontent.com/ros/rosdistro/master/index.yaml'\n\n\n\n\n\nNo differences from ROS 1 Bloom¶\nIf you’ve bloomed packages before in ROS 1, the ROS 2 process is exactly the same.\n\n\nProcedure¶\nSame as in ROS 1: Following this tutorial\nIf porting a ROS 1 package to ROS 2, it’s recommended to create a new -release repository.\n\n\nBuild Status¶\n\nIndividual build details on the build farm Jenkins frontend.\nThe ROS2 Package Status Pages (e.g. Bouncy-Default).\n\n\n\n"},{"id":74,"url":"/doc/ros2/Tutorials/Introspection-with-command-line-tools/","title":"Introspection with command line tools","content":"\nIntrospection with command line tools¶\n\nTable of Contents\n\nUsage\nExample\nBehind the scenes\nImplementation\n\n\nROS 2 includes a suite of command-line tools for introspecting a ROS 2 system.\n\nUsage¶\nThe main entry point for the tools is the command ros2, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more.\nTo see all available sub-commands run:\nros2 --help\n\n\nExamples of sub-commands that are available include:\n\ndaemon: Introspect/configure the ROS 2 daemon\nlaunch: Run a launch file\nlifecycle: Introspect/manage nodes with managed lifecycles\nmsg: Introspect msg types\nnode: Introspect ROS nodes\nparam: Introspect/configure parameters on a node\npkg: Introspect ROS packages\nrun: Run ROS nodes\nsecurity: Configure security settings\nservice: Introspect/call ROS services\nsrv: Introspect srv types\ntopic: Introspect/publish ROS topics\n\n\n\nExample¶\nTo produce the typical talker-listener example using command-line tools, the topic sub-command can be used to publish and echo messages on a topic.\nPublish messages in one terminal with:\n$ ros2 topic pub /chatter std_msgs/String \"data: Hello world\"\npublisher: beginning loop\npublishing std_msgs.msg.String(data='Hello world')\n\npublishing std_msgs.msg.String(data='Hello world')\n\n\nEcho messages received in another terminal with:\n$ ros2 topic echo /chatter\ndata: Hello world\n\ndata: Hello world\n\n\n\n\nBehind the scenes¶\nROS 2 uses a distributed discovery process for nodes to connect to each other.\nAs this process purposefully does not use a centralized discovery mechanism (like the ROS Master in ROS 1), it can take time for ROS nodes to discover all other participants in the ROS graph.\nBecause of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names.\nThe daemon is automatically started when the relevant command-line tools are used for the first time.\nYou can run ros2 daemon --help for more options for interacting with the daemon.\n\n\nImplementation¶\nThe source code for the ros2 command is available at https://github.com/ros2/ros2cli\nThe ros2 tool has been implemented as a framework that can be extended via plugins.\nFor example, the sros2 package provides a security sub-command that is automatically detected by the ros2 tool if the sros2 package is installed.\n\n\n"},{"id":75,"url":"/doc/ros2/Concepts/DDS-and-ROS-middleware-implementations/","title":"ROS 2 and different DDS/RTPS vendors","content":"\nROS 2 and different DDS/RTPS vendors¶\nROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation.\nThis article explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail, but in summary DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different “Quality of Service” options for the transportation.\nDDS is an industry standard which is then implemented by a range of vendors, such as RTI’s implementation Connext or ADLink’s implementation OpenSplice\nRTPS (a.k.a. DDSI-RTPS) is the wire protocol used by DDS to communicate over the network, and there are implementations of that which do not fulfill the full DDS API, but provide sufficient functionality for ROS 2, such as eProsima’s implementation Fast RTPS.\nROS 2 supports multiple DDS/RTPS implementations because it is not necessarily “one size fits all” when it comes to choosing a vendor/implementation.\nThere are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint.\nVendors may provide more than one DDS or RTPS implementation targeted at meeting different needs.\nFor example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time).\nIn order to use a DDS/RTPS implementation with ROS 2, a “ROS Middleware interface” (a.k.a. rmw interface or just rmw) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation’s API and tools.\nIt’s a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project’s needs.\n\nSupported RMW implementations¶\n\n\n\n\n\n\n\n\nProduct name\nLicense\nRMW implementation\nStatus\n\n\n\neProsima Fast RTPS\nApache 2\nrmw_fastrtps_cpp\nFull support. Default RMW. Packaged with binary releases.\n\nRTI Connext\ncommercial, research\nrmw_connext_cpp\nFull support. Support included in binaries, but Connext installed separately.\n\nRTI Connext (dynamic implementation)\ncommercial, research\nrmw_connext_dynamic_cpp\nSupport paused. Full support until alpha 8.*\n\nPrismTech Opensplice\nLGPL (only v6.4), commercial\nrmw_opensplice_cpp\nPartial support. Support included in binaries, but OpenSplice installed separately.\n\nOSRF FreeRTPS\nApache 2\n–\nPartial support. Development paused.\n\n\n\n“Partial support” means that one or more of the features required by the rmw interface is not implemented.\nFor practical information on working with multiple RMW implementations, see the “Working with multiple RMW implementations” tutorial.\n\n\n"}]