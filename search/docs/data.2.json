[{"id":8,"url":"/doc/ros2/Related-Projects/","title":"Related Projects","content":"\nRelated Projects¶\n\n\nIntel ROS2 Projects\n\n\n\n"},{"id":9,"url":"/doc/ros2/Roadmap/","title":"Roadmap","content":"\nRoadmap¶\n\nTable of Contents\n\nPlanned upcoming releases\n\nNext release - D-turtle (June 2019)\nFuture (in no specific order)\n\n\nPast releases\n\n\nFor more information on the design of ROS 2 please see design.ros2.org.\nThe core code for ROS 2 is on the ros2 github organization.\nThe Discourse forum/mailing list for discussing ROS 2 design is ng-ros.\nQuestions should be asked on ROS answers, make sure to include at least the ros2 tag and the rosdistro version you are running, e.g. ardent.\n\nPlanned upcoming releases¶\nThis is a list of the features targeted for development in the future.\nSubject to change.\n\nNext release - D-turtle (June 2019)¶\nThe D-turtle meta ticket on GitHub will in the near future enumerate the ongoing high level tasks as well as references specific tickets with more details.\n\n\nFuture (in no specific order)¶\n\nDesign / Concept¶\n\nIDL format: using IDL 4.2 to specify ROS interfaces (msgs, srvs, actions)\n\nSupport for non-ASCII strings in messages / services\nLeverage new features like grouping and various annotations (comments, units)\nExtend usage to .idl files with just constants and/or declare parameters with ranges\n\n\nProgress on migration plan\nReconsider 1-to-1 mapping of ROS nodes to DDS participants\nUniqueness of node names\noptional XML or YAML frontend for Python-based launch\n\n\n\nInfrastructure and tools¶\n\nBuilding\n\nSupport to generate “fat” packages / archives\nWindows and Mac OS packages\n\n\nDocumentation\n\nImprove documentation platform\nSupport for doc jobs on the ROS 2 buildfarm\nConsider consolidating with design.ros2.org\nProvide three different kinds of content:\n\n“demos” to show features and cover them with tests\n“examples” to show a simple/minimalistic usage which might have multiple ways to do something\n“tutorials” which contain more comments and anchors for the wiki (teaching one recommended way)\n\n\n\n\n\n\n\nNew features¶\nThe trailing stars indicate the rough effort: 1 star for small, 2 stars for medium, 3 stars for large.\n\nActions in Python\nLogging improvements [* / **]\n\nConfiguration specified in a file\nC++ stream operators\nColorize console output\n\n\nParameters\n\nset individual parameters via command line arguments (instead of passing a yaml file)\nSpecify the value range\nDefine read-only parameters\n\n\nAdditional Graph API features [** / ***]\n\na la ROS 1 Master API: http://wiki.ros.org/ROS/Master_API\nEvent-based notification\nRequires knowledge of the rmw interface which needs to be extended\n\n\nRemapping [** / ***]\n\nDynamic remapping and aliasing through a Service interface\n\n\nType masquerading [***]\n\na la ROS 1’s message traits: http://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes\nRequires knowledge of the typesupport system\n\n\nExpand on real-time safety [***]\n\nWith FastRTPS\nFor services, clients, and parameters\nSupport deterministic ordering of executables in Executor (fair scheduling)\nExpose more quality of service parameters related to real-time performance\nReal-time-safe intra-process messaging\n\n\nMulti-robot supporting features and demos [***]\n\nUndesired that all nodes across all robots share the same domain (and discover each other)\nDesign how to “partition” the system\n\n\nImplement C client library rclc [**]\nSupport more DDS / RTPS implementations:\n\nConnext dynamic [*]\nRTI’s micro implementation [*]\nEclipse Cyclone DDS (former ADLINK OpenSplice) [*]\n\n\nsecurity improvements:\n\nmore granularity in security configuration (allow authentication only, authentication and encryption, etc) [*]\nextend access control permission generation to support services [*]\nintegrate DDS-Security logging plugin (unified way to aggregate security events and report them to the users through a ROS interface) [**]\nkey storage security (right now, keys are just stored in the filesystem) [**]\nmore user friendly interface (make it easier to specify security config). Maybe a Qt GUI? This GUI could also assist in distributing keys somehow. [***]\nA way to say “please secure this running system” with some UI that would auto-generate keys and policies for everything that is currently running. [***]\nIf there are hardware-specific features for securing keys or accelerating encryption/signing messages, that could be interesting to add to DDS/RTPS implementations that don’t use it already. [***]\n\n\n\n\n\nPort of existing ROS 1 functionality¶\n\nPerception metapackage\n\nImage pipeline\nImprovements to the intra process comm. to reduce latency / overhead\n\n\nMoveIt\n\nNeeds Actions\nMoveit Maintainers are tracking: https://discourse.ros.org/t/moveit-maintainer-meeting-recap-july-25th-2018/5504\n\n\nRQt\n\nconvert more plugins [* each when dependencies are available]\n\n\nDiagnostics\n\n\n\nReducing Technical Debt¶\n\nExtend testing and resolve bugs in the current code base\n\nWaitset inconsistency\nMulti-threading problems with components\nReduce overhead / latency of intra-process communication\n\n\nFix flaky tests.\nAbility to run (all) unit tests with tools e.g. valgrind\nAPI review\nSynchronize / reconcile design docs with the implementation.\n\nPre-release retrospective review (APIs, docs, etc.)\n\n\nAddress / classify pending tickets\nAddress TODOs in code / docs\n\n\n\n\n\nPast releases¶\nSee list of releases.\n\n\n"},{"id":10,"url":"/doc/ros2/Tutorials/","title":"Tutorials","content":"\nTutorials¶\n\nBasic¶\n\n\nUsing Colcon to build packages\nUsing Ament\nOverview\nHow does it work ?\nCross-compiling ROS2\nCross-compiling examples for Arm\nAutomated Cross-compilation\nCross-compiling against a pre-built ROS2\nRun on the target\nOn the mixing of ament and catkin (catment)\nIntrospection with command line tools\nOverview and Usage of RQt\nPorting RQt plugins to Windows\nPassing ROS arguments to nodes via the command-line\nLaunching/monitoring multiple nodes with Launch\nWorking with multiple ROS 2 middleware implementations\nComposing multiple nodes in a single process\nIntroduction to msg and srv interfaces\nNew features in ROS 2 interfaces\nDefining custom interfaces (msg/srv)\nEclipse Oxygen with ROS 2 and rviz2 [community-contributed]\nBuilding ROS2 on Linux with Eclipse Oxygen [community-contributed]\nBuilding Realtime Linux for ROS 2 [community-contributed]\nReleasing a ROS 2 package with bloom\n\n\n\n\nAdvanced¶\n\n\nImplement a custom memory allocator\n\n\n\n\nUsing Docker¶\n\n\nRunning 2 nodes in a single docker container [community-contributed]\nRunning 2 nodes in 2 separate docker containers [community-contributed]\n\n\n\n\nDemos¶\n\n\n\nUse quality-of-service settings to handle lossy networks.\nManagement of nodes with managed lifecycles.\nEfficient intra-process communication.\nBridge communication between ROS 1 and ROS 2.\nRecording and playback of topic data with rosbag using the ROS 1 bridge.\nTurtlebot 2 demo using ROS 2.\nTurtleBot 3 demo using ROS 2. [community-contributed]\nUsing tf2 with ROS 2.\nWrite real-time safe code that uses the ROS 2 APIs.\nUse the rclpy API to write ROS 2 programs in Python.\nUse the robot state publisher to publish joint states and TF.\nUse DDS-Security.\nLogging and logger configuration.\n\n\n\nExamples¶\n\nPython and C++ minimal examples.\n\n\n\n"},{"id":11,"url":"/doc/ros2/Concepts/About-Quality-of-Service-Settings/","title":"About Quality of Service Settings","content":"\nAbout Quality of Service Settings¶\n\nOverview¶\nROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes.\nWith the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between.\nUnlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a “best effort” policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines.\nA set of QoS “policies” combine to form a QoS “profile”.\nGiven the complexity of choosing the correct QoS policies for a given scenario, ROS 2 provides a set of predefined QoS profiles for common usecases (e.g. sensor data).\nAt the same time, users are given the flexibility to control specific profiles of the QoS policies.\nQoS profiles can be specified for publishers, subscribers, service servers and clients.\nA QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used it is possible that they will not connect.\n\n\nQoS policies¶\nThe base QoS profile currently includes settings for the following policies:\n\nHistory\n\nKeep last: only store up to N samples, configurable via the queue depth option.\nKeep all: store all samples, subject to the configured resource limits of the underlying middleware.\n\n\nDepth\n\nSize of the queue: only honored if used together with “keep last”.\n\n\nReliability\n\nBest effort: attempt to deliver samples, but may lose them if the network is not robust.\nReliable: guarantee that samples are delivered, may retry multiple times.\n\n\nDurability\n\nTransient local: the publisher becomes responsible for persisting samples for “late-joining” subscribers.\nVolatile: no attempt is made to persist samples.\n\n\n\nFor each of the policies there is also the option of “system default”, which uses the default of the underlying middleware which may be defined via DDS vendor tools (e.g. XML configuration files).\nDDS itself has a wider range of policies that can be configured.\nThese policies have been exposed because of their similarity to features in ROS 1; it is possible that in the future more policies will be exposed in ROS 2.\n\nComparison to ROS 1¶\nThe history and depth policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1.\nThe reliability policy in ROS 2 is akin to the use of either UDPROS (only in roscpp) for “best effort”, or TCPROS (ROS 1 default) for reliable.\nNote however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate.\nThe durability policy combined with a depth of 1 provides functionality similar to that of “latching” subscribers.\n\n\n\nQoS profiles¶\nProfiles allow developers to focus on their applications without worrying about every QoS setting possible.\nA QoS profile defines a set of policies that are expected to go well together for a particular use case.\nThe currently-defined QoS profiles are:\n\nDefault QoS settings for publishers and subscribers\nIn order to make the transition from ROS 1 to ROS 2, exercising a similar network behavior is desirable.\nBy default, publishers and subscribers are reliable in ROS 2, have volatile durability, and “keep last” history.\n\nServices\nIn the same vein as publishers and subscribers, services are reliable.\nIt is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests.\nWhile the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests.\n\nSensor data\nFor sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive.\nThat is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some.\nFor that reason the sensor data profile uses best effort reliability and a smaller queue depth.\n\nParameters\nParameters in ROS 2 are based on services, and as such have a similar profile.\nThe difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server.\n\nSystem default\n\nThis uses the system default for all of the policies.\n\n\n\nClick here for the specific policies in use for the above profiles.\nThe settings in these profiles are subject to further tweaks, based on the feedback from the community.\nWhile ROS 2 provides some QoS profiles for common use cases, the use of policies that are defined in DDS allows ROS users to take advantage of the vast knowledge base of existing DDS documentation for configuring QoS profiles for their specific use case.\n\n\nQoS compatibilities¶\nNote: This section refers to publisher and subscribers but the content applies to service servers and clients in the same manner.\nQoS profiles may be configured for publishers and subscribers independently.\nA connection between a publisher and a subscriber is only made if the pair has compatible QoS profiles.\nQoS profile compatibility is determined based on a “Request vs Offerer” model, wherein connections are only made if the requested policy of the subscriber is not more stringent than the that of the publisher.\nThe less strict of the two policies will be the one used for the connection.\nThe QoS policies exposed in ROS 2 that affect compatibility are the durability and reliability policies.\nThe following tables show the compatibility of the different policy settings and the result:\nCompatibility of QoS durability profiles:\n\n\n\n\n\n\n\n\nPublisher\nSubscriber\nConnection\nResult\n\n\n\nVolatile\nVolatile\nYes\nVolatile\n\nVolatile\nTransient local\nNo\n\n\n\n\n\nTransient local\nVolatile\nYes\nVolatile\n\nTransient local\nTransient local\nYes\nTransient local\n\n\n\nCompatibility of QoS reliability profiles:\n\n\n\n\n\n\n\n\nPublisher\nSubscriber\nConnection\nResult\n\n\n\nBest effort\nBest effort\nYes\nBest effort\n\nBest effort\nReliable\nNo\n\n\n\n\n\nReliable\nBest effort\nYes\nBest effort\n\nReliable\nReliable\nYes\nReliable\n\n\n\nIn order for a connection to be made, all of the policies that affect compatibility must be compatible.\nThat is, even if a publisher-subscriber pair has compatible reliability QoS profiles, if they have incompatible durability QoS profiles a connection will not be made, and vice-versa.\n\n\n"}]