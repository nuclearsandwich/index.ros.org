[{"id":16,"url":"/doc/ros2/Tutorials/Launch-system/","title":"Launching/monitoring multiple nodes with Launch","content":"\nLaunching/monitoring multiple nodes with Launch¶\n\nROS 2 launch system¶\nThe launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described.\nThe configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS specific conventions which make it easy to reuse components throughout the system by giving them each different configurations.\nIt is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes.\nThe ROS 2 Bouncy release includes a framework in which launch files, written in Python, can start and stop different nodes as well as trigger and act on various events.\nThe package providing this framework is launch_ros, which uses the non-ROS-specific launch framework underneath.\nThe design document (in review) details the goal of the design of ROS 2’s launch system (not all functionality is currently available).\n\n\nExample of ROS 2 launch concepts¶\nThe launch file in this example launches two nodes, one of which is a node with a managed lifecycle (a “lifecycle node”).\nLifecycle nodes launched through launch_ros automatically emit events when they transition between states.\nThe events can then be acted on through the launch framework, e.g. by emitting other events (such as requesting another state transition, which lifecycle nodes launched through launch_ros automatically have event handlers for) or triggering other actions (e.g. starting another node).\nIn the aforementioned example, various transition requests are requested of the talker lifecycle node, and  its transition events are reacted to by, for example, launching a listener node when the lifecycle talker reaches the appropriate state.\n\n\nUsage¶\nWhile launch files can be written as standalone scripts, the typical usage in ROS is to have launch files invoked by ROS 2 tools.\nFor example, this launch file has been designed such that it can be invoked by ros2 launch:\nros2 launch demo_nodes_cpp add_two_ints.launch.py\n\n\n\n\nDocumentation¶\nThe launch documentation provides more details on concepts that are also used in launch_ros.\nAdditional documentation/examples of capabilities are forthcoming.\nSee the source code in the meantime.\n\n\n"},{"id":17,"url":"/doc/ros2/Tutorials/Managed-Nodes/","title":"Management of nodes with managed lifecycles","content":"\nManagement of nodes with managed lifecycles¶\n\nTable of Contents\n\nIntroduction\nThe demo\nRun the demo\nThe demo code\nOutlook\n\n\n\nIntroduction¶\nROS2 introduces the concept of managed nodes, also called LifecycleNodes. In the following tutorial, we explain the purpose of these nodes, what makes them different from regular nodes and how they comply to a lifecycle management.\nManaged nodes are scoped within a state machine of a finite amount of states. These states can be changed by invoking a transition id which indicates the succeeding consecutive state.\nThe state machine is implemented as described at the ROS2 design page.\nOur implementation differentiates between Primary States and Transition States. Primary States are supposed to be steady states in which any node can do the respected task. On the other hand, Transition States are meant as temporary intermediate states attached to a transition. The result of these intermediate states are used to indicate whether a transition between two primary states is considered successful or not. Thus, any managed node can be in one of the following states:\nPrimary States (steady states):\n\nunconfigured\ninactive\nactive\nshutdown\n\nTransition States (intermediate states):\n\nconfiguring\nactivating\ndeactivating\ncleaningup\nshuttingdown\n\nThe possible transitions to invoke are:\n\nconfigure\nactivate\ndeactivate\ncleanup\nshutdown\n\nFor a more verbose explanation on the applied state machine, we refer to the design page which provides an in-detail explanation about each state and transition.\n\n\nThe demo¶\n\nWhat’s happening¶\nThe demo is split into 3 different separate applications.\n\nlifecycle_talker\nlifecycle_listener\nlifecycle_service_client\n\nThe lifecycle_talker represents a managed node and publishes according to which state the node is in. We split the tasks of the talker node into separate pieces and execute them as followed.\n\nconfiguring: We initialize our publisher and timer\nactivate: We activate the publisher and timer in order to enable a publishing\ndeactivate: We stop the publisher and timer\ncleanup: We destroy the publisher and timer\n\nThe principle is implemented in this demo as the typical talker/listener demo. However, imaging a real scenario with attached hardware which may have a rather long booting phase, i.e. a laser or camera. One could image bringing up the device driver in the configuring state, start and stop only the publishing of the device’s data and only in the cleanup/shutdown phase actually shutdown the device.\nThe lifecycle_listener is a simple listener which shows the characteristics of the lifecycle talker. The talker enables the message publishing only in the active state and thus making the listener receiving only messages when the talker is in an active state.\nThe lifecycle_service_client is a script calling different transitions on the lifecycle_talker. This is meant as the external user controlling the lifecycle of nodes.\n\n\n\nRun the demo¶\nIn order to run this demo, we open three terminals and source our ROS2 environment variables either from the binary distributions or the workspace we compiled from source.\n\n\n\n\n\n\n\nlifecycle_talker\nlifecycle_listener\nlifecycle_service_client\n\n\n\n$ ros2 run lifecycle lifecycle_talker\n$ ros2 run lifecycle lifecycle_listener\n$ ros2 run lifecycle lifecycle_service_client\n\n\n\n\n\n\n\n\n\n\nAlternatively, these three programs can be run together in the same terminal using the launch file (as of ROS 2 Bouncy):\nros2 launch lifecycle lifecycle_demo.launch.py\n\n\nIf we look at the output of the lifecycle_talker, we notice that nothing seems to happen. And this does make sense, since every node starts as unconfigured. The lifecycle_talker is not configured yet and in our example, no publishers and timers are created yet.\nThe same behavior can be seen for the lifecycle_listener, which is less surprising given that no publishers are available at this moment.\nThe interesting part starts with the third terminal. In there we launch our lifecycle_service_client which is responsible for changing the states of the lifecycle_talker.\n\nTriggering transition 1 (configure)¶\n[lc_client] Transition 1 successfully triggered.\n[lc_client] Node lc_talker has current state inactive.\n\n\nmakes the lifecycle talker change its state to inactive. Inactive means that all publishers and timers are created and configured. However, the node is still not active. Therefore no messages are getting published.\n[lc_talker] on_configure() is called.\nLifecycle publisher is currently inactive. Messages are not published.\n...\n\n\nThe lifecycle listener on the same time receives a notification as it listens to every state change notification of the lifecycle talker. In fact, the listener receives two consecutive notifications. One for changing from the primary state “unconfigured” to “configuring”. Because the configuring step was successful within the lifecycle talker, a second notification from “configuring” to “inactive”.\n[lc_listener] notify callback: Transition from state unconfigured to configuring\n[lc_listener] notify callback: Transition from state configuring to inactive\n\n\n\n\nTriggering transition 2 (activate)¶\n[lc_client] Transition 2 successfully triggered.\n[lc_client] Node lc_talker has current state active.\n\n\nmakes the lifecycle talker change its state to active. Active means that all publishers and timers are now activated. Therefore the messages are now getting published.\n[lc_talker] on_activate() is called.\n[lc_talker] Lifecycle publisher is active. Publishing: [Lifecycle HelloWorld #11]\n[lc_talker] Lifecycle publisher is active. Publishing: [Lifecycle HelloWorld #12]\n...\n\n\nThe lifecycle listener receives the same set of notifications as before. Lifecycle talker changed its state from inactive to active.\n[lc_listener] notify callback: Transition from state unconfigured to configuring\n[lc_listener] notify callback: Transition from state configuring to inactive\n\n\nThe difference to the transition event before is that our listener now also receives the actual published data.\n[lc_listener] data_callback: Lifecycle HelloWorld #11\n[lc_listener] data_callback: Lifecycle HelloWorld #12\n...\n\n\nPlease note that the index of the published message is already at 11. The purpose of this demo is to show that even though we call publish at every state of the lifecycle talker, only when the state in active, the messages are actually published. As for the beta1, all other messages are getting ignored. This behavior may change in future versions in order to provide better error handling.\nFor the rest of the demo, you will see similar output as we deactivate and activate the lifecycle talker and finally shut it down.\n\n\n\nThe demo code¶\n\nlifecycle_talker, lifecycle_listener and lifecycle_service_client¶\nIf we have a look at the code, there is one significant change for the lifecycle talker compared to a regular talker. Our node does not inherit from the regular rclcpp::node::Node but from rclcpp_lifecycle::LifecycleNode.\nclass LifecycleTalker : public rclcpp_lifecycle::LifecycleNode\n\n\nEvery child of LifecycleNodes have a set of callbacks provided. These callbacks go along with the applied state machine attached to it. These callbacks are:\n\nrcl_lifecycle_ret_t on_configure(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_activate(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_deactivate(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_cleanup(const rclcpp_lifecycle::State & previous_state)\nrcl_lifecycle_ret_t on_shutdown(const rclcpp_lifecycle::State & previous_state)\n\nAll these callbacks have a positive default return value (return RCL_LIFECYCLE_RET_OK). This allows a lifecycle node to change its state even though no explicit callback function was overwritten.\nThere is one other callback function for error handling. Whenever a state transition throws an uncaught exception, we call on_error.\n\nrcl_lifecycle_ret_t on_error(const rclcpp_lifecycle::State & previous_state)\n\nThis gives room for executing a custom error handling. Only (!) in the case that this function returns RCL_LIFECYCLE_RET_OK, the state machine transitions to the state unconfigured. By default, the on_error returns RCL_LIFECYCLE_RET_ERROR and the state machine transitions into finalized.\nAt the same time, every lifecycle node has by default 5 different communication interfaces.\n\nPublisher <node_name>__transition_event: publishes in case a transition is happening. This allows users to get notified of transition events within the network.\nService <node_name>__get_state: query about the current state of the node. Return either a primary or transition state.\nService <node_name>__change_state: triggers a transition for the current node. This service call takes a transition id. Only in the case, that this transition ID is a valid transition of the current state, the transition is fulfilled. All other cases are getting ignored.\nService <node_name>__get_available_states: This is meant to be an introspection tool. It returns a list of all possible states this node can be.\nService <node_name>__get_available_transitions: Same as above, meant to an introspection tool. It returns a list of all possible transitions this node can execute.\n\n\n\nros2 lifecycle¶\nThe lifecycle_service_client application is a fixed order script for this demo purpose only. It explains the use and the API calls made for this lifecycle implementation, but may be inconvenient to use otherwise. For this reason we implemented a command line tool which lets you dynamically change states or various nodes.\nIn the case you want to get the current state of the lc_talker node, you would call:\n$ ros2 lifecycle get /lc_talker\nunconfigured [1]\n\n\nThe next step would be to execute a state change:\n$ ros2 lifecycle set /lc_talker configure\nTransitioning successful\n\n\nAll of the above commands are nothing else than calling the lifecycle node’s services. With that being said, we can also call these services directly with the ros2 command line interface:\n$ ros2 service call /lc_talker/get_state lifecycle_msgs/GetState\nrequester: making request: lifecycle_msgs.srv.GetState_Request()\n\nresponse:\nlifecycle_msgs.srv.GetState_Response(current_state=lifecycle_msgs.msg.State(id=1, label='unconfigured'))\n\n\nIn order to trigger a transition, we call the change_state service\n$ ros2 service call /lc_talker/change_state lifecycle_msgs/ChangeState \"{transition: {id: 1}}\"\nrequester: making request: lifecycle_msgs.srv.ChangeState_Request(transition=lifecycle_msgs.msg.Transition(id=1, label=''))\n\nresponse:\nlifecycle_msgs.srv.ChangeState_Response(success=True)\n\n\nIt is slightly less convenient, because you have to know the IDs which correspond to each transition. You can find them though in the lifecycle_msgs package.\n$ ros2 msg show lifecycle_msgs/Transition\n\n\n\n\n\nOutlook¶\nThe above description points to the current state of the development as for beta1. The future todo list for this topic comprises:\n\nPython lifecycle nodes\nLifecycle manager: A global node, handling and dispatching trigger requests for multiple nodes.\nLifeyclceSubscriber/LifecycleWalltimer/... add more lifecycle controlled entities.\n\n\n\n"},{"id":18,"url":"/doc/ros2/Releases/Beta3-Overview/","title":"Beta 3 (codename ‘r2b3’; September 2017)","content":"\nBeta 3 (codename ‘r2b3’; September 2017)¶\n\nTable of Contents\n\nSupported Platforms\nFeatures\nImprovements since Beta 2 release\nNew demo application\nSelected features from previous Alpha/Beta releases\n\n\nKnown issues\n\n\n\nSupported Platforms¶\nWe support ROS 2 Beta 3 on three platforms: Ubuntu 16.04 (Xenial), Mac OS X 10.12 (Sierra), and Windows 10.\nWe provide both binary packages and instructions for how to compile from source for all 3 platforms (see install instructions as well as documentation).\n\n\nFeatures¶\n\nImprovements since Beta 2 release¶\n\nExecution model in Python, many fixes to memory management in Python C extension\nExperimental rewrite of ros_control\nExposure of DDS implementation-specific symbols to users (for FastRTPS and Connext) (see example)\nLogging API in Python\nFixed several memory leaks and race conditions in various packages\nReadded support for OpenSplice (on Linux and Windows atm) provided by PrismTech\nUse bloom (without patches) to make ROS 2 releases\n\n\n\nNew demo application¶\n\nHSR demo\nRemote control a HSR robot using a ROS 2 joystick controller\nRunning the ros1_bridge in a Docker container on the HSR (since the robot is running ROS 1 on Ubuntu Trusty)\nRun a ROS 2 development version of rviz to visualize sensor data from the robot etc. (see video)\n\n\n\n\n\nSelected features from previous Alpha/Beta releases¶\nFor the complete list, see earlier release notes.\n\nC++ and Python implementations of ROS 2 client libraries including APIs for:\nPublishing and subscribing to ROS topics\nRequesting and replying ROS services (synchronous (C++ only) and asynchronous)\nGetting and setting ROS parameters (C++ only, synchronous and asynchronous)\nTimer callbacks\n\n\nSupport for interoperability between multiple DDS/RTPS implementations\neProsima FastRTPS is our default implementation, and is included in the binary packages\nRTI Connext is supported: build from source to try it out\nPrismTech OpenSplice: see limitations below\n\n\nA graph API for network events\nDistributed discovery\nRealtime safe code paths for publish and subscribe with compatible DDS implementation (only Connext at the moment)\nSupport for custom allocators\n\n\nROS 1 <-> ROS 2 dynamic bridge node\nExecutor threading model (C++ and Python)\nComponent model to compose nodes at compile / link / runtime\nManaged component using a standard lifecycle\nExtended .msg format with new features:\nBounded arrays\nDefault values\n\n\n\n\n\n\nKnown issues¶\n\nOn Windows Python launch files might hang when trying to abort using Ctrl-C (see issue). In order to continue using the shell which is blocked by the hanging command you might want to end the hanging Python process using the process monitor.\nOpenSplice support is currently not available for MacOS. Also access to native handles is not yet implemented.\nUsing Connext it is currently not allowed for two topics with the same base name but different namespaces to have a different type (see issue).\n\n\n\n"},{"id":19,"url":"/doc/ros2/Releases/Alpha-Overview/","title":"ROS 2 alpha releases (Aug 2015 - Oct 2016)","content":"\nROS 2 alpha releases (Aug 2015 - Oct 2016)¶\n\nTable of Contents\n\nROS 2 alpha8 release (code name Hook-and-Loop; October 2016)\nROS 2 alpha7 release (code name Glue Gun; July 2016)\nROS 2 alpha6 release (code name Fastener; June 2016)\nROS 2 alpha5 release (code name Epoxy; April 2016)\nROS 2 alpha4 release (code name Duct tape; February 2016)\nROS 2 alpha3 release (code name Cement; December 2015)\nROS 2 alpha2 release (code name Baling wire; October 2015)\nROS 2 alpha1 release (code name Anchor; August 2015)\n\n\nThis is a merged version of the previously separated pages for the 8 alpha releases of ROS 2.\nWe hope that you try them out and provide feedback.\n\nROS 2 alpha8 release (code name Hook-and-Loop; October 2016)¶\n\nTable of Contents\n\nChanges to supported DDS vendors\nScope\n\n\n\nChanges to supported DDS vendors¶\nROS 2 supports multiple middleware implementations (see this page for more details).\nUntil Alpha 8, ROS 2 was supporting ROS middleware implementations for eProsima’s Fast RTPS, RTI’s Connext and PrismTech’s OpenSplice.\nTo streamline our efforts, as of Alpha 8, Fast RTPS and Connext (static) will be supported, with Fast RTPS (now Apache 2.0-licensed) shipped as the default.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from complete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.\nRather, you should expect to try out some demos, explore the code, and perhaps write your own demos.\nThe improvements included in this release are:\n\nSeveral improvements to Fast RTPS and its rmw implementation\nSupport for large (image) messages in Fast RTPS\nwait_for_service functionality in Fast RTPS\n\n\nSupport for all ROS 2 message types in Python and C\nAdded support for Quality of Service (QoS) settings in Python\nFixed various bugs with the previous alpha release\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha7 release (code name Glue Gun; July 2016)¶\n\nTable of Contents\n\nNew version of Ubuntu required\nScope\n\n\n\nNew version of Ubuntu required¶\nUntil Alpha 6 ROS 2 was targeting Ubuntu Trusty Tahr (14.04). As of this Alpha ROS 2 is targeting Ubuntu Xenial Xerus (16.04) to benefit from newer versions of the compiler, CMake, Python, etc.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from complete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should you expect to build a new robot control system with ROS 2.\nRather, you should expect to try out some demos, explore the code, and perhaps write your own demos.\nThe major features included in this release are:\n\nGraph API functionality: wait_for_service\nAdded interfaces in rclcpp and make use of them in examples, demos, and tests\n\n\nImproved support for large messages in both Connext and Fast-RTPS (partial for Fast-RTPS)\nTurtlebot demo using ported code from ROS 1\nSee: https://github.com/ros2/turtlebot2_demo\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha6 release (code name Fastener; June 2016)¶\n\nTable of Contents\n\nScope\n\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nGraph API functionality: wait_for_service\nAdded graph guard condition to nodes for waiting on graph changes\nAdded rmw_service_server_is_available for verifying if a service is available\n\n\nRefactored rclcpp to use rcl\nImproved support for complex message types in Python\nNested messages\nArrays\nStrings\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha5 release (code name Epoxy; April 2016)¶\n\nTable of Contents\n\nScope\n\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nSupport for C data structures in Fast RTPS and Connext Dynamic rmw implementations.\nSupport services in C.\nAdded 32-bit and 64-bit ARM as experimentally supported platforms.\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha4 release (code name Duct tape; February 2016)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design article,\nwe are engaged in the development of a new major version of ROS, called “ROS 2.”\nWhile the underlying concepts (e.g., publish / subscribe messaging) and goals\n(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their rationale, consult the other\nROS 2 design articles.\n\n\nStatus¶\nOn February 17, 2016, we are releasing ROS 2 alpha4,\ncode-named Duct tape.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nImproved type support infrastructure, including support for C\nPreliminary Python client library, only publishers and subscriptions are supported. Beware, the API is subject to change and is far from complete!\nAdded structures for ROS time in C API (still needs C++ API)\nNew concept of extensible “time sources” for ROS Time, the default time source will be like ROS 1 (implementation pending)\n\n\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha3 release (code name Cement; December 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design article,\nwe are engaged in the development of a new major version of ROS, called “ROS 2.”\nWhile the underlying concepts (e.g., publish / subscribe messaging) and goals\n(e.g., flexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their rationale, consult the other\nROS 2 design articles.\n\n\nStatus¶\nOn December 18, 2015, we are releasing ROS 2 alpha3,\ncode-named Cement.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous releases.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nUpdated rcl interface.\nThis interface will be wrapped in order to create language bindings, e.g. rclpy.\nThis interface has improved documentation and test coverage over existing interfaces we currently have, e.g. rmw and rclcpp.\nSee rcl headers.\n\n\nAdded support in rclcpp for using the TLSF (two-level segregate fit) allocator, a memory allocator design for embedded and real-time systems.\nImproved efficiency of MultiThreadedExecutor and fixed numerous bugs with multi-threaded execution, which is now test on CI.\nAdded ability to cancel an Executor from within a callback called in spin.\nAdded ability for a timer to cancel itself by supporting a Timer callback that accepts a reference to itself as a function parameter.\nAdded checks for disallowing multiple threads to enter Executor::spin.\nImproved reliability of numerous tests that had been sporadically failing.\nAdded support for using FastRTPS (instead of, e.g., OpenSplice or Connext).\nA partial port of tf2 including the core libraries and core command line tools.\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha2 release (code name Baling wire; October 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design\narticle, we are engaged in\nthe development of a new major version of ROS, called “ROS 2.” While the\nunderlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,\nflexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their\nrationale, consult the other ROS 2 design\narticles.\n\n\nStatus¶\nOn November 3, 2015, we are releasing ROS 2 alpha2,\ncode-named Baling wire.\nOur primary goal with this release is to add more features, while also addressing the feedback we received for the previous alpha 1 release.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nSupport for custom allocators in rclcpp, useful for real-time messaging\nFeature parity of Windows with Linux/OSX, including workspace management, services and parameters\nrclcpp API improvements\nFreeRTPS improvements\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\nROS 2 alpha1 release (code name Anchor; August 2015)¶\n\nTable of Contents\n\nBackground\nStatus\nIntended audience\nScope\n\n\n\nBackground¶\nAs explained in a design\narticle, we are engaged in\nthe development of a new major version of ROS, called “ROS 2.” While the\nunderlying concepts (e.g., publish / subscribe messaging) and goals (e.g.,\nflexibility and reusability) are the same as for ROS 1, we are taking this\nopportunity to make substantial changes to the system, including changing\nsome of the core APIs.\nFor a deeper treatment of those changes and their\nrationale, consult the other ROS 2 design\narticles.\n\n\nStatus¶\nOn August 31, 2015, we are releasing ROS 2 alpha1,\ncode-named Anchor.\nOur primary goal with this release is to give\nyou the opportunity to understand how ROS 2 works, in particular how it\ndiffers from ROS 1.\nTo that end, we built a set of demos that\nshow some of the key features of ROS 2.\nWe encourage you to try out those\ndemos, look at the code that implements them, and provide\nfeedback.\nWe’re especially interested to know how well (or\npoorly) we’re addressing use cases that are important to you.\n\n\nIntended audience¶\nWhile everyone is welcome to try out the demos and look through the code, we’re aiming this release at people who are already experienced with ROS 1 development.\nAt this point, the ROS 2 documentation is pretty sparse and much of the system is explained by way of how it compares to ROS 1.\n\n\nScope¶\nAs the “alpha” qualifier suggests, this release of ROS 2 is far from\ncomplete.\nYou should not expect to switch from ROS 1 to ROS 2, nor should\nyou expect to build a new robot control system with ROS 2.\nRather, you\nshould expect to try out some demos, explore the code, and perhaps write\nyour own demos.\nThe major features included in this release are:\n\nDiscovery, transport, and serialization use DDS\nSupport multiple DDS vendors\nSupport messaging primitives: topics (publish / subscribe), services (request / response), and parameters\nSupport Linux (Ubuntu Trusty), OS X (Yosemite) and Windows (8)\nUse quality-of-service settings to handle lossy networks\nCommunicate inter-process or intra-process with the same API\nWrite real-time safe code that uses the ROS 2 APIs\nRun ROS 2 on “bare-metal” microcontrollers (no operating system)\nBridge communication between ROS 1 and ROS 2\n\nPretty much anything not listed above is not included in this release.\nThe next steps are described in the Roadmap.\n\n\n\n"}]