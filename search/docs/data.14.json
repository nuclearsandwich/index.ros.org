[{"id":56,"url":"/doc/ros2/Tutorials/Cross-compilation/","title":"Overview","content":"\nOverview¶\n\nOpen Robotics provides pre-built ROS2 packages for multiple platforms, but a number of developers still rely on cross-compilation for different reasons such as:\nThe development machine does not match the target system.\nTuning the build for specific core architecture (e.g. setting -mcpu=cortex-a53 -mfpu=neon-fp-armv8 when building for Raspberry Pi3).\nTargeting a different file systems other than the ones supported by the pre-built images released by Open Robotics.\n\n\n\nThis document provides you with details on how to cross-compile the ROS2 software stack as well as provide examples for cross-compiling to systems based on the Arm cores.\n\nNote\nThere are a few ROS2 packages that fail cross-compilation and have to be disabled during the build. See 4. Build section.\n\n\n\nHow does it work ?¶\nCross-compiling simple software (e.g. no dependencies on external libraries) is relatively simple and only requiring a cross-compiler toolchain to be used instead of the native toolchain.\n\nThere are a number of factors which make this process more complex:\nThe software being built must support the target architecture. Architecture specific code must be properly isolated and enabled during the build according to the target architecture. Examples include assembly code.\nAll dependencies (e.g. libraries) must be present, either as pre-built packages or also cross-compiled before the target software using them is cross-compiled.\nWhen building software stacks (as opposed to an standalone software) using build tools (e.g. colcon), it is expected from the build tool a mechanism to allow the developer to enable cross-compilation on the underlying build system used by each of software in the stack.\n\n\n\n\n\nCross-compiling ROS2¶\n\nAlthough ROS2 is a rich software stack with a number of dependencies, it primarily uses two different types of packages:\nPython based software, which requires no cross-compilation.\nCMake based software, which provides a mechanism to do cross-compilation.\n\n\n\nFurthermore, the ROS2 software stack is built with Colcon which provides a mechanism to forward parameters to the CMake instance used for the individual build of each package/library that is part of the ROS2 distribution.\nWhen building ROS2 natively, the developer is required to download all the dependencies (e.g. Python and other libraries) before compiling the packages that are part of the ROS2 distribution. When cross-compiling, the same approach is required. The developer must first have the target system’s filesystem with all dependencies already installed.\nThe next sections of this document explain in detail the use of cmake-toolchains and the CMAKE_SYSROOT feature to cross-compile ROS2.\n\nCMake toolchain-file¶\nA CMake toolchain-file is a file which defines variables to configure CMake for cross-compilation. The basic entries are:\n\n\nCMAKE_SYSTEM_NAME: the target platform, e.g. linux\nCMAKE_SYSTEM_PROCESSOR: the target architecture, e.g. aarch64 or arm\nCMAKE_SYSROOT: the path to the target file-system\nCMAKE_C_COMPILER: the C cross-compiler, e.g. aarch64-linux-gnu-gcc\nCMAKE_CXX_COMPILER: the C++ cross-compiler, e.g. aarch64-linux-gnu-g++\nCMAKE_FIND_ROOT_PATH: an alternative path used by the find_* command to find the file-system\n\n\nWhen cross-compiling ROS2, the following options are required to be set:\n\n\nCMAKE_FIND_ROOT_PATH: the alternative path used by the find_* command, use it to specify the path to ROS2 /install folder\nCMAKE_FIND_ROOT_PATH_MODE_*: the search strategy for program,package,library, and include, usually: NEVER (look on the host-fs), ONLY (look on sysroot), ONLY (look on sysroot) and ONLY (look on sysroot)\nPYTHON_SOABI: the index name of the python libraries generated by ROS2, e.g. cpython-36m-aarch64-linux-gnu\nTHREADS_PTHREAD_ARG \"0\" CACHE STRING \"Result from TRY_RUN\" FORCE: Force the result of the TRY_RUN cmd to 0 (success) because binaries can not run on the host system.\n\n\nThe toolchain-file is provided to CMake with the -DCMAKE_TOOLCHAIN_FILE=path/to/file parameter. This will also set the CMAKE_CROSSCOMPILING variable to true which can be used by the software being built.\nThe CMAKE_SYSROOT is particularly important for ROS2 as the packages need many dependencies (e.g. python, openssl, opencv, poco, eigen3, …).\nSetting CMAKE_SYSROOT to a target file-system with all the dependencies installed on it will allow CMake to find them during the cross-compilation.\n\nNote\nYou can find more information on the CMake documentation page.\n\nWhen dowloading the ROS2 source code, a generic toolchain-file is available in the repository ros2/cross_compile/cmake-toolchains which can be downloaded separately. Further examples on using it can be found on the Cross-compiling examples for Arm section.\n\n\nTarget file-system¶\nAs mentioned previously, ROS2 requires different libraries which needs to be provided to cross-compile.\n\nThere are a number of ways to obtain the file-system:\ndownloading a pre-built image\ninstalling the dependencies on the target and exporting the file-system (e.g. with sshfs)\nusing qemu + docker (or chroot) to generate the file-system on the host machine.\n\n\n\n\nNote\nYou can find information on how to use Docker + qemu on the next Cross-compiling examples for Arm section.\n\n\n\nBuild process¶\nThe build process is similar to native compilation. The only difference is an extra argument to Colcon to specify the toolchain-file:\ncolcon build --merge-install \\\n    --cmake-force-configure \\\n    --cmake-args \\\n        -DCMAKE_TOOLCHAIN_FILE=\"<path_to_toolchain/toolchainfile.cmake>\"\n\n\nThe toolchain-file provide to CMake the information of the cross-compiler and the target file-system.\nColcon will call CMake with the given toolchain-file on every package of ROS2.\n\n\n\nCross-compiling examples for Arm¶\nAfter downloading the ROS2 source code, you can add cross-compilation assets to the workspace via git clone https://github.com/ros2/cross_compile.git src/ros2/cross_compile. These are working examples on how to cross-compile for Arm cores.\n\nThe following targets are supported:\nUbuntu-arm64: To be used with any ARMv8-A based system.\nUbuntu-armhf: To be used with any modern ARMv7-A based system.\n\n\nThese are the main steps:\nInstalling development tools\nDownloading ROS2 source code\nDownloading the ROS2 cross-compilation assets\nPreparing the sysroot\nCross-compiling the ROS2 software stack\n\n\n\nThe next sections explains in detail each of these steps.\nFor a quick-setup, have a look at the Automated Cross-compilation.\n\nNote\nThese steps were tested on an Ubuntu 18.04 (Bionic)\n\n\n1. Install development tools¶\nThis step is similar to when building natively. The difference is that some of the libraries and tools are not required because they will be in the sysroot instead.\nThe following packages are required\nsudo apt update && sudo apt install -y \\\n    cmake \\\n    git \\\n    wget \\\n    python3-pip \\\n    qemu-user-static \\\n    g++-aarch64-linux-gnu \\\n    g++-arm-linux-gnueabihf \\\n    pkg-config-aarch64-linux-gnu\n\npython3 -m pip install -U \\\n    vcstool \\\n    colcon-common-extensions\n\n\n\nNote\nYou can install vcstool and colcon-common-extensions via pip. This\nmeans you are not required to add extra apt repositories.\n\nDocker is used to build the target environment. Follow the official documentation for the installation.\n\n\n2. Download ROS2 source code¶\nThen create a workspace and download the ROS2 source code:\nmkdir -p ~/cc_ws/ros2_ws/src\ncd ~/cc_ws/ros2_ws\nwget https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos\nvcs-import src < ros2.repos\ngit clone https://github.com/ros2/cross_compile.git src/ros2/cross_compile\ncd ..\n\n\n\n\n3. Prepare the sysroot¶\nBuild an arm Ubuntu image with all the ROS2 dependencies using Docker and qemu:\nCopy the qemu-static binary to the workspace.\nIt will be used to install the ros2 dependencies on the target file-system with docker.\nmkdir qemu-user-static\ncp /usr/bin/qemu-*-static qemu-user-static\n\n\nThe standard setup process of ROS2 is run inside an arm docker. This is possible thanks to qemu-static, which will emulate an arm machine. The base image used is an Ubuntu Bionic from Docker Hub.\ndocker build -t aarch64_ros2:latest -f ros2_ws/src/ros2/cross_compile/sysroot/Dockerfile_ubuntu_arm64 .\ndocker run --name aarch64_sysroot aarch64_ros2:latest\n\n\nExport the resulting container to a tarball and extract it:\ndocker container export -o sysroot_docker.tar aarch64_sysroot\nmkdir sysroot_docker\ntar -C sysroot_docker -xf sysroot_docker.tar lib usr opt\n\n\nThis container can be used later as virtual target to run the created file-system and run the demo code.\n\n\n4. Build¶\nSet the variables used by the generic toolchain-file\nexport TARGET_ARCH=aarch64\nexport TARGET_TRIPLE=aarch64-linux-gnu\nexport CC=/usr/bin/$TARGET_TRIPLE-gcc\nexport CXX=/usr/bin/$TARGET_TRIPLE-g++\nexport CROSS_COMPILE=/usr/bin/$TARGET_TRIPLE-\nexport SYSROOT=~/cc_ws/sysroot_docker\nexport ROS2_INSTALL_PATH=~/cc_ws/ros2_ws/install\nexport PYTHON_SOABI=cpython-36m-$TARGET_TRIPLE\n\n\nThe following packages still cause errors during the cross-compilation (under investigation) and must be disabled for now.\ntouch \\\n    ros2_ws/src/ros2/rviz/COLCON_IGNORE \\\n    ros2_ws/src/ros2/demos/intra_process_demo/COLCON_IGNORE \\\n    ros2_ws/src/ros2/demos/image_tools/COLCON_IGNORE \\\n    ros2_ws/src/ros2/robot_state_publisher/COLCON_IGNORE \\\n    ros2_ws/src/ros-visualization/COLCON_IGNORE\n\n\nThen, start a build with colcon specifying the toolchain-file:\ncd ros2_ws\n\ncolcon build --merge-install \\\n    --cmake-force-configure \\\n    --cmake-args \\\n        -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON \\\n        -DCMAKE_TOOLCHAIN_FILE=\"$(pwd)/src/ros2/cross_compile/cmake-toolchains/generic_linux.cmake\" \\\n        -DSECURITY=ON\n\n\nDone! The install and build directories will contain the cross-compiled assets.\n\n\n\nAutomated Cross-compilation¶\nAll the steps above are also included into a Dockerfile and can be used for automation/CI.\nFirst, download the dockerfile and build the image:\nwget https://raw.githubusercontent.com/ros2/cross_compile/master/Dockerfile_cc_for_arm\ndocker build -t ros2-crosscompiler:latest - < Dockerfile_cc_for_arm\n\n\nNow run the image with:\n(it will take a while !)\ndocker run -it --name ros2_cc \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    ros2-crosscompiler:latest\n\n\n..note:: The -v /var/run/docker.sock allow us to use Docker inside Docker.\nThe result of the build will be inside the ros2_ws directory, which can be exported with:\ndocker cp ros2_cc:/root/cc_ws/ros2_ws .\n\n\n\n\nCross-compiling against a pre-built ROS2¶\nIt is possible to cross-compile your packages against a pre-built ROS2. The steps are similar to the previous Cross-compiling examples for Arm section, with the following modifications:\nInstead of downloading the ROS2 stack, just populate your workspace with your package (ros2 examples on this case) and the cross-compilation assets:\nmkdir -p ~/cc_ws/ros2_ws/src\ncd ~/cc_ws/ros2_ws/src\ngit clone https://github.com/ros2/examples.git\ngit clone https://github.com/ros2/cross_compile.git\ncd ..\n\n\nGenerate and export the file-system as described in 3. Prepare the sysroot, but with the provided Dockerfile_ubuntu_arm64_prebuilt. These _prebuilt Dockerfile will use the binary packages to install ROS2 instead of building from source.\nModify the environment variable ROS2_INSTALL_PATH to point to the installation directory:\nexport ROS2_INSTALL_PATH=~/cc_ws/sysroot_docker/opt/ros/crystal\n\n\nSource the setup.bash script on the target file-system:\nsource $ROS2_INSTALL_PATH/setup.bash\n\n\nThen, start a build with Colcon specifying the toolchain-file:\ncolcon build \\\n    --merge-install \\\n    --cmake-force-configure \\\n    --cmake-args \\\n        -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON \\\n        -DCMAKE_TOOLCHAIN_FILE=\"$(pwd)/src/cross_compile/cmake-toolchains/generic_linux.cmake\"\n\n\n\n\nRun on the target¶\nCopy the file-system on your target or use the previously built docker image:\ndocker run -it --rm -v `pwd`/ros2_ws:/ros2_ws aarch64_ros2:latest\n\n\nSource the environment:\nsource /ros2_ws/install/local_setup.bash\n\n\nRun some of the C++ or python examples:\nros2 run demo_nodes_cpp listener &\nros2 run demo_nodes_py talker\n\n\n\n"},{"id":57,"url":"/doc/ros2/Tutorials/RQt-Overview-Usage/","title":"Overview and Usage of RQt","content":"\nOverview and Usage of RQt¶\n\nTable of Contents\n\nOverview\nSystem setup\n\nInstalling From Debian\nBuilding From Source\n\n\nRQt Components Structure\nAdvantage of RQt framework\nFurther Reading\n\n\n\nOverview¶\nRQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins.\nOne can run all the existing GUI tools as dockable windows within RQt!\nThe tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout.\nYou can run any RQt tools/plugins easily by:\nrqt\n\n\nThis GUI allows you to choose any available plugins on your system.\nYou can also run plugins in standalone windows.\nFor example, RQt Python Console:\nros2 run rqt_py_console rqt_py_console\n\n\nUsers can create their own plugins for RQt with either Python or C++.\nOver 20 plugins were created in ROS 1 and these plugins are currently being ported to ROS 2 (as of Dec 2018, more info).\n\n\nSystem setup¶\n\nInstalling From Debian¶\nsudo apt install ros-$ROS_DISTRO-rqt*\n\n\n\n\nBuilding From Source¶\n\n\nSee Building RQt from Source.\n\n\n\nRQt Components Structure¶\nRQt consists of three metapackages:\n\nrqt - core infrastucture modules.\n\nrqt_common_plugins - Backend tools for building tools.TODO: as of Dec 2018 this metapackage isn’t available in ROS 2 since not all plugins it contains have been ported yet.\n\n\n\n\nrqt_robot_plugins - Tools for interacting with robots during runtime.TODO: as of Dec 2018 this metapackage isn’t available in ROS 2 since not all plugins it contains have been ported yet.\n\n\n\n\n\n\nAdvantage of RQt framework¶\nCompared to building your own GUIs from scratch:\n\nStandardized common procedures for GUI (start-shutdown hook, restore previous states).\nMultiple widgets can be docked in a single window.\nEasily turn your existing Qt widgets into RQt plugins.\nExpect support at ROS Answers (ROS community website for the questions).\n\nFrom system architecture’s perspective:\n\nSupport multi-platform (basically wherever QT and ROS run) and multi-language (Python, C++).\nManageable lifecycle: RQt plugins using common API makes maintainance & reuse easier.\n\n\n\nFurther Reading¶\n\nROS 2 Discourse announcment of porting to ROS2).\nRQt for ROS 1 documentation.\nBrief overview of RQt (from a Willow Garage intern blog post).\n\n\n\n\n"},{"id":58,"url":"/doc/ros2/Concepts/Overview-of-ROS-2-concepts/","title":"Overview of ROS 2 Concepts","content":"\nOverview of ROS 2 Concepts¶\n\nTable of Contents\n\nQuick Overview of Graph Concepts\nNodes\nClient Libraries\nDiscovery\nExample: talker-listener\n\n\nROS is a middleware based on an anonymous publish/subscribe mechanism that allows for message passing between different ROS processes.\nAt the heart of any ROS 2 system is the ROS graph.\nThe ROS graph refers to the network of nodes in a ROS system and the connections between them by which they communicate.\n\nQuick Overview of Graph Concepts¶\n\nNodes: A node is an entity that uses ROS to communicate with other nodes.\nMessages: ROS data type used when subscribing or publishing to a topic.\nTopics: Nodes can publish messages to a topic as well as subscribe to a topic to receive messages.\nDiscovery: The automatic process through which nodes determine how to talk to each other.\n\n\n\nNodes¶\nA node is a participant in the ROS graph.\nROS nodes use a ROS client library to communicate with other nodes.\nNodes can publish or subscribe to a Topic.\nNodes can also provide or use a Service.\nThere are configurable Parameters associated with a node.\nConnections between nodes are established through a distributed discovery process.\nNodes may be located in the same process, in different processes, or on different machines.\nThese concepts will be described in more detail in the sections that follow.\n\n\nClient Libraries¶\nROS client libraries allow nodes written in different programming languages to communicate.\nThere is a core ROS client library (RCL) that implements common functionality needed for the ROS APIs of different languages.\nThis makes it so that language-specific client libraries are easier to write and that they have more consistent behavior.\nThe following client libraries are maintained by the ROS 2 team:\n\nrclcpp = C++ client library\nrclpy = Python client library\n\nAdditionally, other client libraries have been developed by the ROS community.\nSee the ROS 2 Client Libraries article for more details.\n\n\nDiscovery¶\nDiscovery of nodes happens automatically through the underlying middleware of ROS 2.\nIt can be summarized as follows:\n\nWhen a node is started, it advertises its presence to other nodes on the network with the same ROS domain (set with the ROS_DOMAIN_ID environment variable).\nNodes respond to this advertisement with information about themselves so that the appropriate connections can be made and the nodes can communicate.\nNodes periodically advertise their presence so that connections can be made with new-found entities, even after the initial discovery period.\nNodes advertise to other nodes when they go offline.\n\nNodes will only establish connections with other nodes if they have compatible Quality of Service settings.\n\n\nExample: talker-listener¶\nIn one terminal, start a node (written in C++) that will publish messages on a topic.\nros2 run demo_nodes_cpp talker\n\n\nIn another terminal, start a second node (written in Python) that will subscribe to messages on the same topic.\nros2 run demo_nodes_py listener\n\n\nYou should see that these nodes discover each other automatically, and begin to exchange messages.\n\n\n"},{"id":59,"url":"/doc/ros2/Tutorials/Node-arguments/","title":"Passing ROS arguments to nodes via the command-line","content":"\nPassing ROS arguments to nodes via the command-line¶\n\nTable of Contents\n\nName remapping\nLogger configuration\nParameters\n\n\nAll ROS nodes take a set of arguments that allow various properties to be reconfigured.\nExamples include configuring the name/namespace of the node, topic/service names used, and parameters on the node.\nNote: all features on this page are only available as of the ROS 2 Bouncy release.\n\nName remapping¶\nNames within a node (e.g. topics/services) can be remapped using the syntax <old name>:=<new name>.\nThe name/namespace of the node itself can be remapped using __node:=<new node name> and __ns:=<new node namespace>.\nNote that these remappings are “static” remappings, in that they apply for the lifetime of the node.\n“Dynamic” remapping of names after nodes have been started is not yet supported.\nSee this design doc for more details on remapping arguments (not all functionality is available yet).\n\nExample¶\nThe following invocation will cause the talker node to be started under the node name my_talker, publishing on the topic named my_topic instead of the default of chatter.\nThe namespace, which must start with a forward slash, is set to /demo, which means that topics are created in that namespace (/demo/my_topic), as opposed to globally (/my_topic).\nros2 run demo_nodes_cpp talker __ns:=/demo __node:=my_talker chatter:=my_topic\n\n\n\nPassing remapping arguments to specific nodes¶\nIf multiple nodes are being run within a single process (e.g. using Composition), remapping arguments can be passed to a specific node using its name as a prefix.\nFor example, the following will pass the remapping arguments to the specified nodes:\nros2 run composition manual_composition talker:__node:=my_talker listener:__node:=my_listener\n\n\n\n\n\n\nLogger configuration¶\nSee __log_level argument usage in the logging page.\n\n\nParameters¶\nParameters support for Python nodes was added in Crystal. In Bouncy only C++ nodes are supported.\nSetting parameters from the command-line is currently supported in the form of yaml files.\nSee here for examples of the yaml file syntax. As an example, save the following as demo_params.yaml\ntalker:\n    ros__parameters:\n        some_int: 42\n        a_string: \"Hello world\"\n        some_lists:\n            some_integers: [1, 2, 3, 4]\n            some_doubles : [3.14, 2.718]\n\n\nThen run the following:\nros2 run demo_nodes_cpp talker __params:=demo_params.yaml\n\n\nOther nodes will be able to retrieve the parameter values, e.g.:\n$ ros2 param list talker\n  a_string\n  some_int\n  some_lists.some_doubles\n  some_lists.some_integers\n\n\n\n\n"}]