[{"id":24,"url":"/doc/ros2/Tutorials/RQt-Source-Install-Windows10/","title":"Building RQt from Source on Windows 10","content":"\nBuilding RQt from Source on Windows 10¶\nThis page provides specific information to building RQt from source on Windows.\nFollow these instructions before proceeding with the RQt Source Install page.\nIf you have not done so, follow the ROS 2 Windows Development Setup guide before continuing.\n\nSystem Requirements¶\n\nWindows 10\nVisual Studio 15.7.6\n\nCurrently Visual Studio 15.8 fails to build ROS 2 (see issue).\nOlder versions of VS can be found here.\n\n\nDependencies¶\nThe primary dependencies of the RQt package are sip and PyQt5.\nPySide2 may be supported in the future.\nEven though they are provided through PyPi and chocolatey, you must install them by source to get compatible versions.\n\nInstall sip by source¶\nDownload from https://www.riverbankcomputing.com/software/sip/download\nRun the x64 Native Tools Command Prompt as Administrator, and cd to the uncompressed source directory.\nRun:\npython3 configure.py\nnmake\nnmake install\n\n\nIf python3 is installed on your system as python, be sure to use that program name instead.\n\n\nInstall PyQt5 by source¶\nDownload from https://www.riverbankcomputing.com/software/pyqt/download5\nRun the x64 Native Tools Command Prompt as Administrator, and cd to the uncompressed source directory.\nI ran into trouble with Qt 5.11.3 and PyQt5 compiling QtNfc, but it can be easily disabled.\npython3 configure.py --disable QtNfc\nnmake\nnmake install\n\n\n\n\nTest that it works¶\nIf install occurred without failure, try the commands below.\nThey should run without issue and you should see 4.19.13 as your sip.exe version.\nsip -V\npython3 -c \"from PyQt5 import QtCore\"\n\n\n\n\nOther dependencies¶\nInstall GraphViz from https://graphviz.gitlab.io/_pages/Download/Download_windows.html.\nInstall pydot and pyparsing:\npip3 install pydot pyparsing\n\n\nPyGraphViz is a test dependency of qt_dotgraph, but it is currently unsupported on Windows and building by source is not straight forward.\nManually merging this patch is the currently recommended solution, but I could not get it to work.\n(see pygraphviz patch)\n\n\n\nInstall RQt by source¶\nContinue with the RQt source install page.\n\n\n"},{"id":25,"url":"/doc/ros2/Tutorials/RQt-Source-Install-MacOS/","title":"Building RQt from Source on macOS","content":"\nBuilding RQt from Source on macOS¶\nThis page provides specific information to building RQt from source on macOS.\nFollow these instructions before proceeding with RQt Source Install page.\n\nSystem Requirements¶\nRQt is supported on macOS 10.12, but 10.13 also seems to work.\n\n\nDependencies¶\nThe primary dependencies of the RQt package are sip and PyQt5.\nPySide2 may be supported in the future.\n\nInstall dependencies¶\n$ brew install sip pyqt5\n$ brew install graphviz\n$ python3 -m pip install pygraphviz pydot\n$ brew link --force qt\n\n\nThis is the quickest solution but may cause issues when upgrading Qt or if other packages are expecting Qt 4.\nAnother option is to update your PATH and CMAKE_PREFIX_PATH to include the Qt install location:\n\n$ export PATH=\"$(brew --prefix qt)/bin:$PATH\"\n$ export CMAKE_PREFIX_PATH=\"$(brew --prefix qt):$CMAKE_PREFIX_PATH\"\n\n\n\n\n\n\nInstall RQt by source¶\nContinue with the RQt source install page.\n\n\n"},{"id":26,"url":"/doc/ros2/Tutorials/Building-Realtime-rt_preempt-kernel-for-ROS-2/","title":"Building Realtime Linux for ROS 2 [community-contributed]","content":"\nBuilding Realtime Linux for ROS 2 [community-contributed]¶\nThis tutorial begins with a clean Ubuntu 16.04.2 install. Actual kernel is 4.13.0-38-generic, but we will install another one.\nIf you are a company or rich person :) using rt_preempt, check https://wiki.linuxfoundation.org/realtime/rtl/blog#preempt-rt-history .\nCheck on https://wiki.linuxfoundation.org/realtime/start what the latest stable version is, at this time it is  Latest Stable Version 4.9-rt. If we click on the link, we get the exact version, it is patch-4.9.84-rt62.patch.gz\n\nWe create a directory in our home dir with\nmkdir ~/kernel\n\n\nand switch into it with\ncd ~/kernel\n\n\nWe can go with a browser to https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ and see if the version is there, then download it with\nwget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.9.84.tar.gz\n\n\nunpack it with\ntar -xzf linux-4.9.84.tar.gz\n\n\nrename it to the same name with postfix of the patch version\nmv linux-4.9.84 linux-4.9.84-rt62\n\n\ndownload rt_preempt patch with\nwget ftp.ntu.edu.tw/linux/kernel/projects/rt/4.9/older/patch-4.9.84-rt62.patch.gz\n\n\nunpack it with\ngunzip patch-4.9.84-rt62.patch.gz\n\n\nThen switch into the linux directory with\ncd linux-4.9.84-rt62/\n\n\nand patch the kernel with the realtime patch\npatch -p1 < ../patch-4.9.84-rt62.patch\n\n\n\nWe simply wanna use the config of our ubuntu installation, so we use the ubuntu config with\ncp /boot/config-4.13.0-38-generic .config\n\n\nTo enable all ubuntu-configurations, we simply use\nyes '' | make oldconfig\n\n\nWe need some tools, install them with\nsudo apt install libncurses5-dev build-essential libssl-dev ccache\n\n\nThen we need to enable rt_preempt in the kernel. We call\nmake menuconfig\n\n\nand choose under “Processor Type and Features”  —  “Preemption Model”  — “Fully Preemptible kernel (RT)”\n\nExit menuconfig and run\nmake\n\n\nYou could use “make -j4” if you got 4-cpu-cores to build faster.\nThen we need to build the kernel modules with\nsudo make modules_install\n\n\nThen we install the kernel to /boot and update grub with\nsudo make install\n\n\n\n\n"},{"id":27,"url":"/doc/ros2/Tutorials/Composition/","title":"Composing multiple nodes in a single process","content":"\nComposing multiple nodes in a single process¶\n\nTable of Contents\n\nROS 1 - Nodes vs. Nodelets\nROS 2 - Unified API\nWriting a Component\nUsing Components\nRun the demos\n\nRun-time composition using ROS services (1.) with a publisher and subscriber\nRun-time composition using ROS services (1.) with a server and client\nCompile-time composition using ROS services (2.)\nRun-time composition using dlopen\n\n\n\n\n\nROS 1 - Nodes vs. Nodelets¶\nIn ROS 1 you can write your code either as a ROS node or as a ROS nodelet.\nROS 1 nodes are being compiled into executables.\nROS 1 nodelets on the other hand are being compiled into a shared library which is then being loaded at runtime by a container process.\n\n\nROS 2 - Unified API¶\nIn ROS 2 the recommended way of writing your code is that of a nodelet - we call it a Component.\nThis enables to easily add common concepts to existing code, like a life cycle.\nThe biggest drawback of different APIs is being avoided in ROS 2 - both approaches can use the same API in ROS 2.\n\nIt will still be possible to use the node-like style of “writing your own main” but for the common case it is not recommended.\n\nBy making the process layout a deploy-time decision the user can choose between:\n\nrunning multiple nodes in separate processes with the benefits of process/fault isolation as well as easier debugging of individual nodes and\nrunning multiple nodes in a single process with the lower overhead and optionally more efficient communication (see Intra Process Communication).\n\nThe vision is that a future version of ros2 launch will support making these different deployments easily configurable.\n\n\nWriting a Component¶\nSince a component is only built into a shared library it doesn’t have a main function (see Talker source code).\nA component subclasses from rclcpp::Node.\nSince it is not in control of the thread it shouldn’t perform any long running or even blocking tasks in its constructor.\nInstead it can use timers to get periodic notification.\nAdditionally it can create publishers, subscribers, servers, and clients.\nAn important aspect of making such a class a component is that the class registers itself using the package class_loader (see last line in the source code).\nThis makes the component discoverable when its library is being loaded into a running process - it acts as kind of an entry point.\n\n\nUsing Components¶\nThe composition package contains a couple of different approaches how to use components.\nThe two most common ones are:\n\nYou start a generic container process (1) and call the ROS service load_node offered by the container.\nThe ROS service will then load the component specified by the passed package name and library name and start executing it within the running process.\nInstead of calling the ROS service programmatically you can also use a command line tool to invoke the ROS service with the passed command line arguments\nYou create a custom executable containing multiple nodes which are known at compile time.\nThis approach requires that each component has a header file (which is not strictly needed for the first case).\n\n\n\nRun the demos¶\nThe executables from the composition packages can be run with the following commands:\n\nRun-time composition using ROS services (1.) with a publisher and subscriber¶\nIn the first shell:\nros2 run composition api_composition\n\n\nIn the second shell (see talker source code):\nros2 run composition api_composition_cli composition composition::Talker\n\n\nNow the first shell should show a message that the component was loaded as well as repeated message for publishing a message.\nAnother command in the second shell (see listener source code):\nros2 run composition api_composition_cli composition composition::Listener\n\n\nNow the first shell should show repeated output for each received message.\n\nThe demo uses hardcoded topic names and therefore you can’t run api_composition twice.\nBut in general it would be possible to run to separate container processes and load the talker and listener into separate ones and they would still communicate with each other.\n\n\n\nRun-time composition using ROS services (1.) with a server and client¶\nThe example with a server and a client is very similar.\nIn the first shell:\nros2 run composition api_composition\n\n\nIn the second shell (see server and client source code):\nros2 run composition api_composition_cli composition composition::Server\nros2 run composition api_composition_cli composition composition::Client\n\n\nIn this case the client sends a request to the server, the server processes the request and replies with a response, and the client prints the received response.\n\n\nCompile-time composition using ROS services (2.)¶\nThis demos shows that the same shared libraries can be reused to compile a single executable running multiple components.\nThe executable contains all four components from above: talker and listener as well as server and client.\nIn the shell call (see source code):\nros2 run composition manual_composition\n\n\nThis should show repeated messages from both pairs, the talker and the listener as well as the server and the client.\n\n\nRun-time composition using dlopen¶\nThis demo presents an alternative to 1. by creating a generic container process and pass it explicitly the libraries to load without using ROS interfaces.\nThe process will open each library and create one instance of each “rclcpp::Node” class in the library source code).\nLinux In the shell call:\nros2 run composition dlopen_composition `ros2 pkg prefix composition`/lib/libtalker_component.so `ros2 pkg prefix composition`/lib/liblistener_component.so\n\n\nOSX In the shell call:\nros2 run composition dlopen_composition `ros2 pkg prefix composition`/lib/libtalker_component.dylib `ros2 pkg prefix composition`/lib/liblistener_component.dylib\n\n\nWindows In cmd.exe call\nros2 pkg prefix composition\n\n\nto get the path to where composition is installed. Then call\nros2 run composition dlopen_composition <path_to_composition_install>\\bin\\talker_component.dll <path_to_composition_install>\\bin\\listener_component.dll\n\n\nNow the shell should show repeated output for each sent and received message.\n\n\n\n"}]