[{"id":76,"url":"/doc/ros2/Tutorials/Run-2-nodes-in-a-single-docker-container/","title":"Running 2 nodes in a single docker container [community-contributed]","content":"\nRunning 2 nodes in a single docker container [community-contributed]¶\nPull the ROS2 docker image with tag “ardent-basic”.\ndocker pull osrf/ros2:ardent-basic\n\n\nRun the image in a container in interactive mode.\n$ docker run -it osrf/ros2:ardent-basic\nroot@<container-id>:/#\n\n\nYour best friend is the ros2 command line help now.\nroot@<container-id>:/# ros2 --help\n\n\nE.g. list all installed packages.\nroot@<container-id>:/# ros2 pkg list\n(you will see a list of packages)\n\n\nE.g. list all executables:\nroot@<container-id>:/# ros2 pkg executables\n(you will see a list of <package> <executable>)\n\n\nRun a minimal example of 2 C++ nodes (1 topic subscriber listener, 1 topic publisher talker) from the package demo_nodes_cpp in this container:\nros2 run demo_nodes_cpp listener &\nros2 run demo_nodes_cpp talker\n\n\n\n"},{"id":77,"url":"/doc/ros2/Tutorials/Working-with-multiple-RMW-implementations/","title":"Working with multiple ROS 2 middleware implementations","content":"\nWorking with multiple ROS 2 middleware implementations¶\n\nTable of Contents\n\nPre-requisites\nMultiple RMW implementations\nDefault RMW implementation\nSpecifying RMW implementations\nAdding RMW implementations to your workspace\nTroubleshooting\nEnsuring use of a particular RMW implementation\n\n\n\n\nThis page explains the default RMW implementation and how to specify an alternative.\n\nPre-requisites¶\nYou should have already read the DDS and ROS middleware implementations page.\n\n\nMultiple RMW implementations¶\nThe current ROS 2 binary releases have built-in support for several RMW implementations out of the box (Fast RTPS, RTI Connext Pro, and ADLink OpenSplice at the time of writing), but only Fast RTPS (the default) works without any additional installation steps, because it is the only one we distribute with our binary packages.\nOthers like OpenSplice or Connext can be enabled by installing additional packages, but without having to rebuild anything or replace any existing packages.\nAlso, a ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously.\nWhile the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured.\nFor example, if the code for the RMW package for RTI Connext is in the workspace, it will be built if an installation of RTI’s Connext Pro can also be found.\nFor many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances.\nA list of supported inter-vendor communication configurations is forthcoming.\n\n\nDefault RMW implementation¶\nIf a ROS 2 workspace has multiple RMW implementations, the default RMW implementation is currently selected as Fast RTPS if it’s available.\nIf the Fast RTPS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used.\nThe implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. rmw_fastrtps_cpp.\nFor example, if both rmw_opensplice_cpp and rmw_connext_cpp ROS packages are installed, rmw_connext_cpp would be the default.\nIf rmw_fastrtps_cpp is ever installed, it would be the default.\nSee below for how to specify which RMW implementation is to be used when running the ROS 2 examples.\n\n\nSpecifying RMW implementations¶\nTo have multiple RMW implementations available for use you must have installed our binaries and any additional dependencies for specific RMW implementations, or built ROS 2 from source with multiple RMW implementations in the workspace (they are included by default) and their dependencies are met (for example see the Linux install instructions).\n\nStarting in Beta 2 and above both C++ and Python nodes support an environment variable RMW_IMPLEMENTATION.\nTo choose a different RMW implemenation you can set the environment variable RMW_IMPLEMENTATION to a specific implementation identifier.\nTo run the talker demo using the C++ and listener using python with the RMW implementation for connext:\nBash\nRMW_IMPLEMENTATION=rmw_connext_cpp ros2 run demo_nodes_cpp talker\n\n# Run in another terminal\nRMW_IMPLEMENTATION=rmw_connext_cpp ros2 run demo_nodes_py listener\n\n\nWindows cmd.exe\nset RMW_IMPLEMENTATION=rmw_connext_cpp\nros2 run demo_nodes_cpp talker\n\nREM run in another terminal\nset RMW_IMPLEMENTATION=rmw_connext_cpp\nros2 run demo_nodes_py listener\n\n\n\n\nAdding RMW implementations to your workspace¶\nSuppose that you have built your ROS 2 workspace with only Fast RTPS installed and therefore only the Fast RTPS RMW implementation built.\nThe last time your workspace was built, any other RMW implementation packages, rmw_connext_cpp for example, were probably unable to find installations of the relevant DDS implementations.\nIf you then install an additional DDS implementation, Connext for example, you will need to re-trigger the check for a Connext installation that occurs when the Connext RMW implementation is being built.\nYou can do this by specifying the --force-cmake-configure flag on your next workspace build, and you should see that the RMW implementation package then gets built for the newly installed DDS implementation.\nIt is possible to run into a problem when “rebuilding” the workspace with an additional RMW implementation using the --force-cmake-configure option where the build complains about the default RMW implementation changing.\nTo resolve this, you can either set the default implementation to what is was before with the RMW_IMPLEMENTATION CMake argument or you can delete the build folder for packages that complain and continue the build with --start-with <package name>.\n\n\nTroubleshooting¶\n\nEnsuring use of a particular RMW implementation¶\n\nROS 2 Ardent and later¶\nIf the RMW_IMPLEMENTATION environment variable is set to an RMW implementation for which support is not installed, you will see an error message similar to the following if you have only one implementation installed:\nExpected RMW implementation identifier of 'rmw_connext_cpp' but instead found 'rmw_fastrtps_cpp', exiting with 102.\n\n\nIf you have support for multiple RMW implementations installed and you request use of one that is not installed, you will see something similar to:\nError getting RMW implementation identifier / RMW implementation not installed (expected identifier of 'rmw_connext_cpp'), exiting with 1.\n\n\nIf this occurs, double check that your ROS 2 installation includes support for the RMW implementation that you have specified in the RMW_IMPLEMENTATION environment variable.\n\n\n\n\n"},{"id":78,"url":"/doc/ros2/Tutorials/New-features-in-ROS-2-interfaces-(msg-srv)/","title":"New features in ROS 2 interfaces","content":"\nNew features in ROS 2 interfaces¶\nINCOMPLETE\nThe ROS 2 interface definition language, or IDL, is closely related to the ROS 1 IDL.\nMost existing ROS 1 .msg and .srv files should be usable as-is with ROS 2.\nAtop that existing feature set, the ROS 2 IDL introduces some new features, namely:\n\nbounded arrays: Whereas the ROS 1 IDL allows unbounded arrays (e.g., int32[] foo) and fixed-size arrays (e.g., int32[5] bar), the ROS 2 IDL further allows bounded arrays (e.g., int32[<=5] bat).\nThere are use cases in which it’s important to be able to place an upper bound on the size of an array without committing to always using that much space (e.g., in a real-time system in which you need to preallocate all memory that will be used during execution).\nbounded strings: Whereas the ROS 1 IDL allows unbounded strings (e.g., string foo), the ROS 2 IDL further allows bounded strings (e.g., string<=5 bar).\ndefault values: Whereas the ROS 1 IDL allows constant fields (e.g., int32 X=123), the ROS 2 IDL further allows default values to be specified (e.g., int32 X 123).\nThe default value is used when constructing a message/service object and can be subsequently overridden by assigning to the field.\nNote: in ROS Ardent, default values are not supported for complex types or string arrays or strings with encoding.\nNote: in ROS Bouncy, default values are not supported for complex types or string with encoding.\n\n\n"},{"id":79,"url":"/doc/ros2/Tutorials/Building-ROS-2-on-Linux-with-Eclipse-Oxygen/","title":"Building ROS2 on Linux with Eclipse Oxygen [community-contributed]","content":"\nBuilding ROS2 on Linux with Eclipse Oxygen [community-contributed]¶\n\nWarning\nSome people have reported issues about this tutorial.\nIf the steps work for you please leave a comment on https://github.com/ros2/ros2/issues/495 .\nIf they don’t then please comment with the first step that didn’t work.\n\nThis tutorial is based on a clean ubuntu-16.04.2 install and eclipse oxygen with egit. It uses RTI Connext as middleware for Realtime performance. The original Install page is perhaps more up-to-date, so check it for info.\nInstall:\nsudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list'\nsudo apt-key adv --keyserver ha.pool.sks-keyservers.net --recv-keys 421C365BD9FF1F717815A3895523BAEEB01FA116\n\n\nsudo apt update\nsudo apt install git wget build-essential cppcheck cmake libopencv-dev python-empy python3-dev python3-empy python3-nose python3-pip python3-pyparsing python3-setuptools python3-vcstool python3-yaml libtinyxml-dev libeigen3-dev clang-format pydocstyle pyflakes python3-coverage python3-mock python3-pep8 uncrustify libasio-dev libtinyxml2-dev libcurl4-openssl-dev libqt5core5a libqt5gui5 libqt5opengl5 libqt5widgets5 libxaw7-dev libgles2-mesa-dev libglu1-mesa-dev qtbase5-dev\n\n\nThen install\nsudo pip3 install argcomplete flake8 flake8-blind-except flake8-builtins flake8-class-newline flake8-comprehensions flake8-deprecated flake8-docstrings flake8-import-order flake8-quotes pytest pytest-cov pytest-runner\n\n\nCreate a eclipse workspace named ros2_ws. (The name is not needed to be ros2_ws)\n\nInside this eclipse-workspace we create a C++ Project. With this option we have a indexer for code-completion.\n\nWe name the project ros2_ws\n\nWe see our project and some includes. These includes dont reside in our workspace, so dont remove, they are for the indexer.\n\nWe create a folder inside our project, named “src”\n\nWe see the folder in our project. This folder also exist in our workspace.\nAfter that we go to a console and switch to directory /home/ros/ros2_ws/ros2_ws there we enter\nwget https://raw.githubusercontent.com/ros2/ros2/release-latest/ros2.repos\nvcs-import src < ros2.repos\n\n\nadd export RTI_LICENSE_FILE=/home/ros/rti_connext_dds-5.3.1/rti_license.dat to .bashrc and source it.\n\nWe now need a RTI license, which we get on their website. Refer to Linux Development Setup page. The RTI license file will be directly send per email after sign-up.\nIn the email is a link to the RTI software to download. We run the .run file after chmod +x\n\n\nWe choose our home directory to install\n\n\n\nIn the Launcher which started, we select our RTI license file and copy it global\n\nselect in the down-left side the install-button\n\ninstall the security package from RTI software\n\nand the openssl package\n\nUnpack the openssl-1.0.2n package and copy it to the RTI install directory. source /home/ros/rti_connext_dds-5.3.1/resource/scripts/rtisetenv_x64Linux3gcc5.4.0.bash on a console and export RMW_IMPLEMENTATION=rmw_connext_cpp.\nClose eclipse-IDE and open it from the shell we sourced all the scripts from above.We now open in Eclipse the Project->Preferences and go to Environment.\n\nWe enter environment variables. We can get the vars simply by opening a bash console, then we run “env > /tmp/out”, then source the ROS 2 local_setup.bash, then “env > /tmp/out1” and “diff /tmp/out /tmp/out1”. The output that diff is showing, is what we enter in eclipse environment vars, so that eclipse knows about e.g. the new PATH var.\n\n\nThen we go to Builders and click the “New” button.\n\nWe enter the amen.py settings\n\nAfter that we unselect CDT-Builder\n\nThen we go to C++ Build and delete the build command make, because we use ament.py (Dont know really if this is needed\nas we disabled CDT-Builder before?)\n\nWe now can right-click and run “Build Project”.\nHINT if it happens:\nerror: NDDSHOME set to  but could neither find   all optimized libraries nor all debug libraries\nI deleted dir /home/ros/rti_connext_dds-5.3.1/lib/x64Linux3gcc5.4.0/5.3.1/5.3.1  with doubled libs\n\nWe can then open two console, source ros2_ws/install/local_setup.bash in both consoles and run talker and listener\n\nWe see our Project in eclipse, go to git-repositories-view and import local repo\n\nWe select our directory and select the repository we are interresting in seeing e.g. git-infos like author of code-line, or switching to other branches, etc.\n\nAfter adding the git-repo to the git-repository-view, we can right-click on it and select “Import projects”\n\nThe import source is the directory of our project\n\nWe see in the down-left side in the project-explorer view, that this project is beside our ros2_ws project. But they both use the same files.But one is linked with Egit and can show git-annotations, etc. the other not. So open files from the project which is linked to Egit.\n\nFile linked with Egit. Right-click beside the line-number in the editor and choose “Show Revision information” from the pop-up dialog, then you could see e.g. the author, and other stuff like commit message if you hover over it with the mouse.\n\n\n"}]